// ========================================================================
//   This File Is Generated by hir-preinitory.py ! Do Not Modify !
// ========================================================================

namespace lavascript {
namespace cbase      {
namespace hir        {
// Node
template<> struct HIRTypePredicate<Node> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Closure>::Value:
      case HIRTypeValue<Float64Arithmetic>::Value:
      case HIRTypeValue<End>::Value:
      case HIRTypeValue<ListIndex>::Value:
      case HIRTypeValue<InitBarrier>::Value:
      case HIRTypeValue<IRObject>::Value:
      case HIRTypeValue<GGet>::Value:
      case HIRTypeValue<OSRLoad>::Value:
      case HIRTypeValue<EffectPhi>::Value:
      case HIRTypeValue<Checkpoint>::Value:
      case HIRTypeValue<Start>::Value:
      case HIRTypeValue<Call>::Value:
      case HIRTypeValue<GSet>::Value:
      case HIRTypeValue<UGet>::Value:
      case HIRTypeValue<BranchStartEffect>::Value:
      case HIRTypeValue<LoopExit>::Value:
      case HIRTypeValue<SString>::Value:
      case HIRTypeValue<Arithmetic>::Value:
      case HIRTypeValue<InlineEnd>::Value:
      case HIRTypeValue<Jump>::Value:
      case HIRTypeValue<SStringNe>::Value:
      case HIRTypeValue<EmptyWriteEffect>::Value:
      case HIRTypeValue<OSRStart>::Value:
      case HIRTypeValue<StringCompare>::Value:
      case HIRTypeValue<Nil>::Value:
      case HIRTypeValue<TestType>::Value:
      case HIRTypeValue<ItrNext>::Value:
      case HIRTypeValue<ItrDeref>::Value:
      case HIRTypeValue<Float64Compare>::Value:
      case HIRTypeValue<ISet>::Value:
      case HIRTypeValue<ObjectInsert>::Value:
      case HIRTypeValue<LoopHeader>::Value:
      case HIRTypeValue<ObjectRefGet>::Value:
      case HIRTypeValue<Float64Negate>::Value:
      case HIRTypeValue<BooleanNot>::Value:
      case HIRTypeValue<ListRefGet>::Value:
      case HIRTypeValue<PSet>::Value:
      case HIRTypeValue<InitCls>::Value:
      case HIRTypeValue<ObjectUpdate>::Value:
      case HIRTypeValue<Box>::Value:
      case HIRTypeValue<ListInsert>::Value:
      case HIRTypeValue<JumpValue>::Value:
      case HIRTypeValue<IfFalse>::Value:
      case HIRTypeValue<ConvNBoolean>::Value:
      case HIRTypeValue<SStringEq>::Value:
      case HIRTypeValue<OSREnd>::Value:
      case HIRTypeValue<Success>::Value:
      case HIRTypeValue<Float64>::Value:
      case HIRTypeValue<ItrTest>::Value:
      case HIRTypeValue<Region>::Value:
      case HIRTypeValue<Arg>::Value:
      case HIRTypeValue<PGet>::Value:
      case HIRTypeValue<Phi>::Value:
      case HIRTypeValue<IfTrue>::Value:
      case HIRTypeValue<LString>::Value:
      case HIRTypeValue<USet>::Value:
      case HIRTypeValue<StackSlot>::Value:
      case HIRTypeValue<Ternary>::Value:
      case HIRTypeValue<IRList>::Value:
      case HIRTypeValue<Return>::Value:
      case HIRTypeValue<Loop>::Value:
      case HIRTypeValue<LoopEffectPhi>::Value:
      case HIRTypeValue<Compare>::Value:
      case HIRTypeValue<IGet>::Value:
      case HIRTypeValue<Projection>::Value:
      case HIRTypeValue<ItrNew>::Value:
      case HIRTypeValue<Unbox>::Value:
      case HIRTypeValue<Float64Bitwise>::Value:
      case HIRTypeValue<ICall>::Value:
      case HIRTypeValue<Logical>::Value:
      case HIRTypeValue<Unary>::Value:
      case HIRTypeValue<ConvBoolean>::Value:
      case HIRTypeValue<Guard>::Value:
      case HIRTypeValue<Boolean>::Value:
      case HIRTypeValue<ListRefSet>::Value:
      case HIRTypeValue<InlineStart>::Value:
      case HIRTypeValue<CondTrap>::Value:
      case HIRTypeValue<Fail>::Value:
      case HIRTypeValue<ObjectRefSet>::Value:
      case HIRTypeValue<BooleanLogic>::Value:
      case HIRTypeValue<If>::Value:
      case HIRTypeValue<ObjectFind>::Value:
      case HIRTypeValue<IRObjectKV>::Value:
      case HIRTypeValue<Trap>::Value:
        return true;
      default:
        return false;
    }
  }
};

// Expr
template<> struct HIRTypePredicate<Expr> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Closure>::Value:
      case HIRTypeValue<ListIndex>::Value:
      case HIRTypeValue<ISet>::Value:
      case HIRTypeValue<IRObject>::Value:
      case HIRTypeValue<GGet>::Value:
      case HIRTypeValue<OSRLoad>::Value:
      case HIRTypeValue<EffectPhi>::Value:
      case HIRTypeValue<Checkpoint>::Value:
      case HIRTypeValue<Call>::Value:
      case HIRTypeValue<GSet>::Value:
      case HIRTypeValue<UGet>::Value:
      case HIRTypeValue<SString>::Value:
      case HIRTypeValue<Arithmetic>::Value:
      case HIRTypeValue<ItrNew>::Value:
      case HIRTypeValue<PGet>::Value:
      case HIRTypeValue<SStringNe>::Value:
      case HIRTypeValue<EmptyWriteEffect>::Value:
      case HIRTypeValue<StringCompare>::Value:
      case HIRTypeValue<Nil>::Value:
      case HIRTypeValue<TestType>::Value:
      case HIRTypeValue<ListInsert>::Value:
      case HIRTypeValue<ItrDeref>::Value:
      case HIRTypeValue<Float64Compare>::Value:
      case HIRTypeValue<ObjectRefGet>::Value:
      case HIRTypeValue<Float64Negate>::Value:
      case HIRTypeValue<BooleanNot>::Value:
      case HIRTypeValue<ListRefGet>::Value:
      case HIRTypeValue<PSet>::Value:
      case HIRTypeValue<InitCls>::Value:
      case HIRTypeValue<ObjectUpdate>::Value:
      case HIRTypeValue<Box>::Value:
      case HIRTypeValue<ConvNBoolean>::Value:
      case HIRTypeValue<SStringEq>::Value:
      case HIRTypeValue<Float64Arithmetic>::Value:
      case HIRTypeValue<BranchStartEffect>::Value:
      case HIRTypeValue<Float64>::Value:
      case HIRTypeValue<ItrTest>::Value:
      case HIRTypeValue<ListRefSet>::Value:
      case HIRTypeValue<Phi>::Value:
      case HIRTypeValue<LString>::Value:
      case HIRTypeValue<USet>::Value:
      case HIRTypeValue<StackSlot>::Value:
      case HIRTypeValue<Ternary>::Value:
      case HIRTypeValue<IRList>::Value:
      case HIRTypeValue<ObjectFind>::Value:
      case HIRTypeValue<LoopEffectPhi>::Value:
      case HIRTypeValue<Compare>::Value:
      case HIRTypeValue<IGet>::Value:
      case HIRTypeValue<Projection>::Value:
      case HIRTypeValue<InitBarrier>::Value:
      case HIRTypeValue<Unbox>::Value:
      case HIRTypeValue<Float64Bitwise>::Value:
      case HIRTypeValue<ICall>::Value:
      case HIRTypeValue<Logical>::Value:
      case HIRTypeValue<Unary>::Value:
      case HIRTypeValue<ConvBoolean>::Value:
      case HIRTypeValue<Guard>::Value:
      case HIRTypeValue<Boolean>::Value:
      case HIRTypeValue<ItrNext>::Value:
      case HIRTypeValue<Arg>::Value:
      case HIRTypeValue<ObjectInsert>::Value:
      case HIRTypeValue<ObjectRefSet>::Value:
      case HIRTypeValue<BooleanLogic>::Value:
      case HIRTypeValue<IRObjectKV>::Value:
        return true;
      default:
        return false;
    }
  }
};

// ControlFlow
template<> struct HIRTypePredicate<ControlFlow> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<JumpValue>::Value:
      case HIRTypeValue<End>::Value:
      case HIRTypeValue<Success>::Value:
      case HIRTypeValue<InlineEnd>::Value:
      case HIRTypeValue<CondTrap>::Value:
      case HIRTypeValue<Region>::Value:
      case HIRTypeValue<Return>::Value:
      case HIRTypeValue<IfFalse>::Value:
      case HIRTypeValue<IfTrue>::Value:
      case HIRTypeValue<Jump>::Value:
      case HIRTypeValue<Start>::Value:
      case HIRTypeValue<Trap>::Value:
      case HIRTypeValue<InlineStart>::Value:
      case HIRTypeValue<OSREnd>::Value:
      case HIRTypeValue<Fail>::Value:
      case HIRTypeValue<OSRStart>::Value:
      case HIRTypeValue<LoopExit>::Value:
      case HIRTypeValue<LoopHeader>::Value:
      case HIRTypeValue<Loop>::Value:
      case HIRTypeValue<If>::Value:
        return true;
      default:
        return false;
    }
  }
};

// Test
template<> struct HIRTypePredicate<Test> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<TestType>::Value:
        return true;
      default:
        return false;
    }
  }
};

// Guard
template<> struct HIRTypePredicate<Guard> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Guard>::Value;
  }
};
// Checkpoint
template<> struct HIRTypePredicate<Checkpoint> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Checkpoint>::Value;
  }
};
// StackSlot
template<> struct HIRTypePredicate<StackSlot> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<StackSlot>::Value;
  }
};
// ConvBoolean
template<> struct HIRTypePredicate<ConvBoolean> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ConvBoolean>::Value;
  }
};
// ConvNBoolean
template<> struct HIRTypePredicate<ConvNBoolean> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ConvNBoolean>::Value;
  }
};
// Float64
template<> struct HIRTypePredicate<Float64> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Float64>::Value;
  }
};
// Boolean
template<> struct HIRTypePredicate<Boolean> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Boolean>::Value;
  }
};
// LString
template<> struct HIRTypePredicate<LString> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<LString>::Value;
  }
};
// SString
template<> struct HIRTypePredicate<SString> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<SString>::Value;
  }
};
// Nil
template<> struct HIRTypePredicate<Nil> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Nil>::Value;
  }
};
// Unary
template<> struct HIRTypePredicate<Unary> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Unary>::Value;
  }
};
// Logical
template<> struct HIRTypePredicate<Logical> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Logical>::Value;
  }
};
// Ternary
template<> struct HIRTypePredicate<Ternary> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Ternary>::Value;
  }
};
// Float64Negate
template<> struct HIRTypePredicate<Float64Negate> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Float64Negate>::Value;
  }
};
// BooleanNot
template<> struct HIRTypePredicate<BooleanNot> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<BooleanNot>::Value;
  }
};
// SpecializeBinary
template<> struct HIRTypePredicate<SpecializeBinary> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<SStringNe>::Value:
      case HIRTypeValue<SStringEq>::Value:
      case HIRTypeValue<StringCompare>::Value:
      case HIRTypeValue<Float64Bitwise>::Value:
      case HIRTypeValue<Float64Compare>::Value:
      case HIRTypeValue<BooleanLogic>::Value:
      case HIRTypeValue<Float64Arithmetic>::Value:
        return true;
      default:
        return false;
    }
  }
};

// EffectNode
template<> struct HIRTypePredicate<EffectNode> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ListIndex>::Value:
      case HIRTypeValue<ISet>::Value:
      case HIRTypeValue<IRObject>::Value:
      case HIRTypeValue<GGet>::Value:
      case HIRTypeValue<ItrNext>::Value:
      case HIRTypeValue<Call>::Value:
      case HIRTypeValue<GSet>::Value:
      case HIRTypeValue<ListRefGet>::Value:
      case HIRTypeValue<UGet>::Value:
      case HIRTypeValue<Arithmetic>::Value:
      case HIRTypeValue<ItrNew>::Value:
      case HIRTypeValue<EmptyWriteEffect>::Value:
      case HIRTypeValue<PSet>::Value:
      case HIRTypeValue<ListInsert>::Value:
      case HIRTypeValue<ItrDeref>::Value:
      case HIRTypeValue<LoopEffectPhi>::Value:
      case HIRTypeValue<ObjectRefGet>::Value:
      case HIRTypeValue<ObjectUpdate>::Value:
      case HIRTypeValue<BranchStartEffect>::Value:
      case HIRTypeValue<ItrTest>::Value:
      case HIRTypeValue<ListRefSet>::Value:
      case HIRTypeValue<USet>::Value:
      case HIRTypeValue<ObjectInsert>::Value:
      case HIRTypeValue<IRList>::Value:
      case HIRTypeValue<ObjectFind>::Value:
      case HIRTypeValue<Compare>::Value:
      case HIRTypeValue<IGet>::Value:
      case HIRTypeValue<InitBarrier>::Value:
      case HIRTypeValue<ICall>::Value:
      case HIRTypeValue<PGet>::Value:
      case HIRTypeValue<EffectPhi>::Value:
      case HIRTypeValue<ObjectRefSet>::Value:
        return true;
      default:
        return false;
    }
  }
};

// MemoryNode
template<> struct HIRTypePredicate<MemoryNode> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Arg>::Value:
        return true;
      default:
        return false;
    }
  }
};

// OSRLoad
template<> struct HIRTypePredicate<OSRLoad> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<OSRLoad>::Value;
  }
};
// IRObjectKV
template<> struct HIRTypePredicate<IRObjectKV> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<IRObjectKV>::Value;
  }
};
// PhiNode
template<> struct HIRTypePredicate<PhiNode> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Phi>::Value:
        return true;
      default:
        return false;
    }
  }
};

// Projection
template<> struct HIRTypePredicate<Projection> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Projection>::Value;
  }
};
// Closure
template<> struct HIRTypePredicate<Closure> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Closure>::Value;
  }
};
// InitCls
template<> struct HIRTypePredicate<InitCls> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<InitCls>::Value;
  }
};
// Box
template<> struct HIRTypePredicate<Box> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Box>::Value;
  }
};
// Unbox
template<> struct HIRTypePredicate<Unbox> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Unbox>::Value;
  }
};
// Trap
template<> struct HIRTypePredicate<Trap> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Trap>::Value;
  }
};
// CondTrap
template<> struct HIRTypePredicate<CondTrap> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<CondTrap>::Value;
  }
};
// LoopHeader
template<> struct HIRTypePredicate<LoopHeader> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<LoopHeader>::Value;
  }
};
// LoopExit
template<> struct HIRTypePredicate<LoopExit> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<LoopExit>::Value;
  }
};
// If
template<> struct HIRTypePredicate<If> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<If>::Value;
  }
};
// IfTrue
template<> struct HIRTypePredicate<IfTrue> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<IfTrue>::Value;
  }
};
// IfFalse
template<> struct HIRTypePredicate<IfFalse> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<IfFalse>::Value;
  }
};
// Merge
template<> struct HIRTypePredicate<Merge> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Fail>::Value:
      case HIRTypeValue<Region>::Value:
      case HIRTypeValue<Success>::Value:
      case HIRTypeValue<Loop>::Value:
        return true;
      default:
        return false;
    }
  }
};

// Start
template<> struct HIRTypePredicate<Start> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Start>::Value;
  }
};
// End
template<> struct HIRTypePredicate<End> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<End>::Value;
  }
};
// OSRStart
template<> struct HIRTypePredicate<OSRStart> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<OSRStart>::Value;
  }
};
// OSREnd
template<> struct HIRTypePredicate<OSREnd> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<OSREnd>::Value;
  }
};
// InlineStart
template<> struct HIRTypePredicate<InlineStart> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<InlineStart>::Value;
  }
};
// InlineEnd
template<> struct HIRTypePredicate<InlineEnd> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<InlineEnd>::Value;
  }
};
// Jump
template<> struct HIRTypePredicate<Jump> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Jump>::Value;
  }
};
// JumpWithValue
template<> struct HIRTypePredicate<JumpWithValue> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Return>::Value:
      case HIRTypeValue<JumpValue>::Value:
        return true;
      default:
        return false;
    }
  }
};

// TestType
template<> struct HIRTypePredicate<TestType> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<TestType>::Value;
  }
};
// Float64Arithmetic
template<> struct HIRTypePredicate<Float64Arithmetic> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Float64Arithmetic>::Value;
  }
};
// Float64Bitwise
template<> struct HIRTypePredicate<Float64Bitwise> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Float64Bitwise>::Value;
  }
};
// Float64Compare
template<> struct HIRTypePredicate<Float64Compare> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Float64Compare>::Value;
  }
};
// StringCompare
template<> struct HIRTypePredicate<StringCompare> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<StringCompare>::Value;
  }
};
// SStringEq
template<> struct HIRTypePredicate<SStringEq> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<SStringEq>::Value;
  }
};
// SStringNe
template<> struct HIRTypePredicate<SStringNe> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<SStringNe>::Value;
  }
};
// BooleanLogic
template<> struct HIRTypePredicate<BooleanLogic> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<BooleanLogic>::Value;
  }
};
// ReadEffect
template<> struct HIRTypePredicate<ReadEffect> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ListIndex>::Value:
      case HIRTypeValue<GGet>::Value:
      case HIRTypeValue<UGet>::Value:
      case HIRTypeValue<ObjectRefGet>::Value:
      case HIRTypeValue<ListRefGet>::Value:
      case HIRTypeValue<ObjectFind>::Value:
        return true;
      default:
        return false;
    }
  }
};

// WriteEffect
template<> struct HIRTypePredicate<WriteEffect> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ItrNew>::Value:
      case HIRTypeValue<ISet>::Value:
      case HIRTypeValue<IRObject>::Value:
      case HIRTypeValue<IRList>::Value:
      case HIRTypeValue<Call>::Value:
      case HIRTypeValue<GSet>::Value:
      case HIRTypeValue<Arithmetic>::Value:
      case HIRTypeValue<ListInsert>::Value:
      case HIRTypeValue<EmptyWriteEffect>::Value:
      case HIRTypeValue<PSet>::Value:
      case HIRTypeValue<ItrDeref>::Value:
      case HIRTypeValue<LoopEffectPhi>::Value:
      case HIRTypeValue<BranchStartEffect>::Value:
      case HIRTypeValue<ItrTest>::Value:
      case HIRTypeValue<ListRefSet>::Value:
      case HIRTypeValue<USet>::Value:
      case HIRTypeValue<ObjectInsert>::Value:
      case HIRTypeValue<ItrNext>::Value:
      case HIRTypeValue<ObjectUpdate>::Value:
      case HIRTypeValue<Compare>::Value:
      case HIRTypeValue<IGet>::Value:
      case HIRTypeValue<InitBarrier>::Value:
      case HIRTypeValue<ICall>::Value:
      case HIRTypeValue<PGet>::Value:
      case HIRTypeValue<EffectPhi>::Value:
      case HIRTypeValue<ObjectRefSet>::Value:
        return true;
      default:
        return false;
    }
  }
};

// Arg
template<> struct HIRTypePredicate<Arg> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Arg>::Value;
  }
};
// Phi
template<> struct HIRTypePredicate<Phi> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Phi>::Value;
  }
};
// Loop
template<> struct HIRTypePredicate<Loop> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Loop>::Value;
  }
};
// Region
template<> struct HIRTypePredicate<Region> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Region>::Value;
  }
};
// Fail
template<> struct HIRTypePredicate<Fail> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Fail>::Value;
  }
};
// Success
template<> struct HIRTypePredicate<Success> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Success>::Value;
  }
};
// Return
template<> struct HIRTypePredicate<Return> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Return>::Value;
  }
};
// JumpValue
template<> struct HIRTypePredicate<JumpValue> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<JumpValue>::Value;
  }
};
// UGet
template<> struct HIRTypePredicate<UGet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<UGet>::Value;
  }
};
// GGet
template<> struct HIRTypePredicate<GGet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<GGet>::Value;
  }
};
// StaticRef
template<> struct HIRTypePredicate<StaticRef> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ListIndex>::Value:
      case HIRTypeValue<ObjectFind>::Value:
        return true;
      default:
        return false;
    }
  }
};

// RefGet
template<> struct HIRTypePredicate<RefGet> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ObjectRefGet>::Value:
      case HIRTypeValue<ListRefGet>::Value:
        return true;
      default:
        return false;
    }
  }
};

// USet
template<> struct HIRTypePredicate<USet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<USet>::Value;
  }
};
// GSet
template<> struct HIRTypePredicate<GSet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<GSet>::Value;
  }
};
// EffectBarrier
template<> struct HIRTypePredicate<EffectBarrier> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Compare>::Value:
      case HIRTypeValue<IGet>::Value:
      case HIRTypeValue<ItrNew>::Value:
      case HIRTypeValue<BranchStartEffect>::Value:
      case HIRTypeValue<ISet>::Value:
      case HIRTypeValue<ItrTest>::Value:
      case HIRTypeValue<ItrDeref>::Value:
      case HIRTypeValue<LoopEffectPhi>::Value:
      case HIRTypeValue<EffectPhi>::Value:
      case HIRTypeValue<PGet>::Value:
      case HIRTypeValue<InitBarrier>::Value:
      case HIRTypeValue<PSet>::Value:
      case HIRTypeValue<ObjectUpdate>::Value:
      case HIRTypeValue<ObjectInsert>::Value:
      case HIRTypeValue<ItrNext>::Value:
      case HIRTypeValue<Arithmetic>::Value:
      case HIRTypeValue<ListInsert>::Value:
        return true;
      default:
        return false;
    }
  }
};

// EmptyWriteEffect
template<> struct HIRTypePredicate<EmptyWriteEffect> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<EmptyWriteEffect>::Value;
  }
};
// Call
template<> struct HIRTypePredicate<Call> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Call>::Value;
  }
};
// ICall
template<> struct HIRTypePredicate<ICall> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ICall>::Value;
  }
};
// RefSet
template<> struct HIRTypePredicate<RefSet> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ListRefSet>::Value:
      case HIRTypeValue<ObjectRefSet>::Value:
        return true;
      default:
        return false;
    }
  }
};

// IRList
template<> struct HIRTypePredicate<IRList> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<IRList>::Value;
  }
};
// IRObject
template<> struct HIRTypePredicate<IRObject> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<IRObject>::Value;
  }
};
// ObjectFind
template<> struct HIRTypePredicate<ObjectFind> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ObjectFind>::Value;
  }
};
// ListIndex
template<> struct HIRTypePredicate<ListIndex> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ListIndex>::Value;
  }
};
// ObjectRefGet
template<> struct HIRTypePredicate<ObjectRefGet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ObjectRefGet>::Value;
  }
};
// ListRefGet
template<> struct HIRTypePredicate<ListRefGet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ListRefGet>::Value;
  }
};
// HardBarrier
template<> struct HIRTypePredicate<HardBarrier> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Compare>::Value:
      case HIRTypeValue<IGet>::Value:
      case HIRTypeValue<ItrNew>::Value:
      case HIRTypeValue<BranchStartEffect>::Value:
      case HIRTypeValue<ISet>::Value:
      case HIRTypeValue<ItrTest>::Value:
      case HIRTypeValue<ItrDeref>::Value:
      case HIRTypeValue<LoopEffectPhi>::Value:
      case HIRTypeValue<EffectPhi>::Value:
      case HIRTypeValue<PGet>::Value:
      case HIRTypeValue<InitBarrier>::Value:
      case HIRTypeValue<PSet>::Value:
      case HIRTypeValue<ItrNext>::Value:
      case HIRTypeValue<Arithmetic>::Value:
        return true;
      default:
        return false;
    }
  }
};

// SoftBarrier
template<> struct HIRTypePredicate<SoftBarrier> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ObjectInsert>::Value:
      case HIRTypeValue<ObjectUpdate>::Value:
      case HIRTypeValue<ListInsert>::Value:
        return true;
      default:
        return false;
    }
  }
};

// ObjectRefSet
template<> struct HIRTypePredicate<ObjectRefSet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ObjectRefSet>::Value;
  }
};
// ListRefSet
template<> struct HIRTypePredicate<ListRefSet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ListRefSet>::Value;
  }
};
// ItrNew
template<> struct HIRTypePredicate<ItrNew> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ItrNew>::Value;
  }
};
// ItrNext
template<> struct HIRTypePredicate<ItrNext> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ItrNext>::Value;
  }
};
// ItrTest
template<> struct HIRTypePredicate<ItrTest> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ItrTest>::Value;
  }
};
// ItrDeref
template<> struct HIRTypePredicate<ItrDeref> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ItrDeref>::Value;
  }
};
// DynamicBinary
template<> struct HIRTypePredicate<DynamicBinary> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<Compare>::Value:
      case HIRTypeValue<Arithmetic>::Value:
        return true;
      default:
        return false;
    }
  }
};

// EffectPhiBase
template<> struct HIRTypePredicate<EffectPhiBase> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<EffectPhi>::Value:
      case HIRTypeValue<LoopEffectPhi>::Value:
        return true;
      default:
        return false;
    }
  }
};

// InitBarrier
template<> struct HIRTypePredicate<InitBarrier> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<InitBarrier>::Value;
  }
};
// BranchStartEffect
template<> struct HIRTypePredicate<BranchStartEffect> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<BranchStartEffect>::Value;
  }
};
// PGet
template<> struct HIRTypePredicate<PGet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<PGet>::Value;
  }
};
// PSet
template<> struct HIRTypePredicate<PSet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<PSet>::Value;
  }
};
// IGet
template<> struct HIRTypePredicate<IGet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<IGet>::Value;
  }
};
// ISet
template<> struct HIRTypePredicate<ISet> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ISet>::Value;
  }
};
// ObjectResize
template<> struct HIRTypePredicate<ObjectResize> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ObjectInsert>::Value:
      case HIRTypeValue<ObjectUpdate>::Value:
        return true;
      default:
        return false;
    }
  }
};

// ListResize
template<> struct HIRTypePredicate<ListResize> {
  static bool Test(IRType type) {
    switch(type) {
      case HIRTypeValue<ListInsert>::Value:
        return true;
      default:
        return false;
    }
  }
};

// Arithmetic
template<> struct HIRTypePredicate<Arithmetic> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Arithmetic>::Value;
  }
};
// Compare
template<> struct HIRTypePredicate<Compare> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<Compare>::Value;
  }
};
// EffectPhi
template<> struct HIRTypePredicate<EffectPhi> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<EffectPhi>::Value;
  }
};
// LoopEffectPhi
template<> struct HIRTypePredicate<LoopEffectPhi> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<LoopEffectPhi>::Value;
  }
};
// ObjectUpdate
template<> struct HIRTypePredicate<ObjectUpdate> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ObjectUpdate>::Value;
  }
};
// ObjectInsert
template<> struct HIRTypePredicate<ObjectInsert> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ObjectInsert>::Value;
  }
};
// ListInsert
template<> struct HIRTypePredicate<ListInsert> {
  static bool Test(IRType type) {
    return type == HIRTypeValue<ListInsert>::Value;
  }
};
} // namespace hir
} // namespace cbase
} // namespace lavascript
