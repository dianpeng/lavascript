#include "bytecode-interpreter.h"
#include "dep/dynasm/dasm_proto.h"
#include "dep/dynasm/dasm_x86.h"

namespace lavascript {
namespace interpreter{

/* ----------------------------------------------
 *
 * Helper functions for interpreter
 *
 * ---------------------------------------------*/

Value InterpreterDoArithmetic( Sandbox* sandbox ,
                               Value left ,
                               Value right ,
                               Bytecode bc ) {
}

namespace {

// A frame object that is used to record the function's runtime
// information
struct Frame {
  void* caller;
  std::int32_t offset;
};

struct BuildContext {
  dasm_State* dstate;
};

|.arch x64
|.actionlist actions

/* ---------------------------------------------------------------
 * summary of register usage
 * --------------------------------------------------------------*/
// Sandbox pointer
|.define SANDBOX r12

// Current prototype's GCRef pointer
|.define PROTO r13   // callee saved

// Top stack's pointer
|.define STACK r14   // callee saved

// Dispatch table pointer
|.define DISPATCH r15  // callee saved

// Bytecode array
|.define PC rbx      // callee saved

// Hold the decoded unit
|.define INSTR eax
|.define INSTR_OP al
|.define INSTR_A8 ah
|.define INSTR_A16 ax
|.define OP bl

// Instruction's argument
|.define ARG1_8 bl
|.define ARG1_16 bx

|.define ARG2_8 al
|.define ARG2_16 ax

|.define ARG3_8 cl
|.define ARG3_16 cx

// temporary register are r10 and r11
|.define LREG rsi
|.define LREGL esi

|.define RREG rdx
|.define RREGL edx

// registers for normal C function calling ABI
|.define CARG1 rdi
|.define CARG2 rsi
|.define CARG3 rdx
|.define CARG4 rcx
|.define CARG5 r8
|.define CARG6 r9

|.define CARG1L edi
|.define CARG2L esi
|.define CARG3L edx
|.define CARG4L ecx
|.define CARG5L r8d
|.define CARG6L r9d

|.define CARG1LL dil
|.define CARG2LL sil
|.define CARG3LL dl
|.define CARG4LL cl
|.define CARG5LL r8b
|.define CARG6LL r9b

/* ---------------------------------------------------------------
 * dispatch table
 * --------------------------------------------------------------*/
|.macro NextInstr
|  mov INSTR,[PC]
|  movzx OP,INSTR_OP
|  add PC,4
|  jmp aword [DISPATCH+OP*8]
|.endmacro

/* ---------------------------------------------------------------
 * decode each instruction's argument based on blablabla
 * --------------------------------------------------------------*/
|.macro Instr_TypeB
|  movzx ARG1_8,INSTR_A8
|  shl INSTR,16
|.endmacro

|.macro Instr_TypeC
|  shl INSTR,8
|  movzx ARG1_16,INSTR_A16
|  shl INSTR,16
|.endmacro

|.macro Instr_TypeD
|  movzx ARG1_8,INSTR_A8
|  shl PC,16
|  movzx ARG3_8,INSTR_A8
|.endmacro

|.macro Instr_TypeE
|  movzx ARG1_8,INSTR_A8
|  shl PC,16
|.endmacro

|.macro Instr_TypeF
|  movzx ARG1_8,INSTR_A8
|.endmacro

|.macro Instr_TypeG
|  shl PC,8
|  movzx ARG1_16,INSTR_A16
|.endmacro

|.macro Instr_TypeX
|.endmacro

|.macro Instr_TypeN
|  Instr_TypeD
|.endmacro


/* -----------------------------------------------------------
 * constant loading
 * ----------------------------------------------------------*/

|.macro LdInt,reg,index
|  mov reg,[PROTO]
|  mov reg,[reg+index*4+PrototypeLayout::IntTableOffset]
|.endmacro

|.macro LdReal,temp,reg,index
|  mov temp [PROTO]
|  cvtsi2sd reg,dword [reg+index*4+PrototypeLayout::IntTableOffset]
|.endmacro

|.macro check_num,where,real_label,int_label
|  cmp where,Value::TAG_REAL
|  jb > real_label
|  cmp where,Value::TAG_INTEGER
|  je > int_label
|.endmacro


/* -----------------------------------------------------------
 * helper functions/routines generation
 * ----------------------------------------------------------*/
void GenerateHelper( BuildContext* bctx ) {
  /* ----------------------------------------
   * InterpArithXXX                         |
   * ---------------------------------------*/
  |->InterpArithIntL
  | mov CARG1,SANDBOX
  | LdInt CARG2,ARG1_16
  | call extern InterpreterDoArithmetic
  | cmp rax,Value::TAG_NULL
  | je ->InterpFail
  | Dispatch

  |->InterpArithIntR
  | mov CARG1,SANDBOX
  | LdInt CARG3,ARG2_16
  | call extern InterpreterDoArithmetic
  | cmp rax,Value::TAG_NULL
  | je ->InterpFail
  | Dispatch

  |->InterpArithRealL
  | mov CARG1,SANDBOX
  | LdReal CARG2,xmm0,ARG1_16
  | movd CARG2,xmm0
  | call extern InterpreterDoArithmetic
  | cmp rax,Value::TAG_NULL
  | je ->InterpFail
  | Dispatch

  |->InterpArithRealR
  | mov CARG1,SANDBOX
  | LdReal CARG3,xmm0,ARG2_16
  | movd CARG3,xmm0
  | call extern InterpreterDoArithmetic
  | cmp rax,Value::TAG_NULL
  | je ->InterpFail
  | Dispatch

}


// rdi ---> hold *Sandbox* object
// rsi ---> hold *starting* point of the stack object
void GenerateOneBytecode( BuildContext* bctx, Bytecode bc ) {
  switch(bc) {
    case BC_ADDIV:
      |=> bc:
      | Instr_TypeC
      | mov RREG,[STACK+ARG2_8*8]
      | check_num,RREG,1,2

      // slow path
      | mov CARG4LL,BC_ADDIV
      | jmp ->InterpArithL

      // the value is a real number here
      |1:
      | LdReal,LREG,xmm0,ARG1_16
      | movd xmm1,RREG
      | addsd xmm0,xmm1
      | movd [ACC],xmm0
      | Dispatch

      // the value is an integer here
      |2:
      | LdInt,LREG,ARG1_16
      | movzx,RREG,RREGL
      | add LREG,RREG
      | mov [ACC],LREG
      | Dispatch
      break;
  }
}


} // namespace
} // namespace lavascript
} // namespace interpreter
