#include "bytecode-interpreter.h"
#include "src/trace.h"
#include "src/os.h"

#include <math.h>
#include <Zydis/Zydis.h>

namespace lavascript {
namespace interpreter{
namespace {

// Used in dynasm library
int ResolveExternAddress( void**,unsigned char*,int,int );

// Workaround for ODR
#include "dep/dynasm/dasm_proto.h"
#define DASM_EXTERN_FUNC(a,b,c,d) ResolveExternAddress((void**)a,b,c,d)
#include "dep/dynasm/dasm_x86.h"


/**
 * The protocol of this function is carefully arranged and have dependency
 * of how we orgnize our assembly code. So do not modify the protocol unless
 * you know what is going on
 */
Value InterpreterDoArithmetic( Sandbox* sandbox ,
                               Value left ,  // rsi
                               Value right , // rdx
                               Bytecode bc ) {
  (void)sandbox;
  (void)left;
  (void)right;
  (void)bc;
  return Value();
}

Value InterpreterPow         ( Sandbox* sandbox ,
                               Value left,
                               Value right,
                               Bytecode bc ) {
  (void)sandbox;
  (void)left;
  (void)right;
  (void)bc;
  return Value();
}

void InterpreterModByReal    ( Sandbox* sandbox , std::uint32_t* pc ) {
  (void)sandbox;
  (void)pc;
}

void InterpreterDivByZero    ( Sandbox* sandbox , std::uint32_t* pc ) {
  (void)sandbox;
  (void)pc;
}

double Pow( double a , double b ) {
  return pow(a,b);
}

// A frame object that is used to record the function's runtime information
struct Frame {
  void* caller;
  std::int32_t offset;
};

struct BuildContext {
  dasm_State* dasm_ctx;
  int tag;
};

|.arch x64
|.actionlist actions
|.globals GLBNAME_
|.globalnames glbnames
|.externnames extnames

|.macro prolog,reserve
|.if 0
|   push rbp
|   mov rbp,rsp
||  if(reserve) {
|     sub rsp,reserve
||  }
|.endif
|.endmacro

|.macro epilog
|.if 0
|   mov rsp,rbp
|   pop rbp
|.endif
|.endmacro

/* -------------------------------------------------------------------
 * 64 bits call
 *
 * Since 64 bits call cannot accept a imm value due to it is too long,
 * we need to generate different *types* of call instruction based on
 * the callsite
 * -------------------------------------------------------------------*/
inline bool CheckAddress( std::uintptr_t addr ) {
  static const std::uintptr_t k2G = 0x80000000;
  if(addr > 0 && addr < k2G)
    return true;
  else
    return false;
}

|.macro fcall,FUNC
|| if(CheckAddress(reinterpret_cast<std::uintptr_t>(FUNC))) {
|    call extern FUNC
|| } else {
||   lava_info("%s","Function FUNC address is not in 0-2GB");
|.if 0
// I don't know whether this is faster than use rax , need profile. I see
// this one is used in MoarVM. It uses memory address to workaraoud the
// address space problem. But I am kind of unsure about it since it maybe
// because MoarVM already allocate rax for other things
|9:
|.dword (std::uint32_t)((std::uintptr_t)(FUNC)),(std::uint32_t)((std::uintptr_t)((FUNC)>>32))
|    call qword[<9]
|.else
|    mov64 rax, reinterpret_cast<std::uintptr_t>(FUNC)
|    call rax
|.endif
|| }
|.endmacro

/* ---------------------------------------------------------------
 * summary of register usage                                     |
 * --------------------------------------------------------------*/
// Sandbox pointer
|.define SANDBOX,               r12   // callee saved

// Current prototype's GCRef pointer
|.define PROTO,                 r13   // callee saved

// Top stack's pointer
|.define STK,                   r14   // callee saved
|.define ACCIDX,                1020
|.define ACCFIDX,               1024
|.define ACC,                   STK+ACCIDX

// Dispatch table pointer
|.define DISPATCH,              r15  // callee saved

// Bytecode array
|.define PC,                    rbx  // callee saved

// Hold the decoded unit
|.define INSTR,                 eax
|.define INSTR_OP,              al
|.define INSTR_A8,              ah
|.define INSTR_A16,             ax
|.define OP,                    rbx

// Instruction's argument
|.define ARG1_8,                bl
|.define ARG1_16,               bx
|.define ARG1,                  rbx

|.define ARG2_8,                al
|.define ARG2_16,               ax
|.define ARG2,                  rax

|.define ARG3_8,                cl
|.define ARG3_16,               cx
|.define ARG3,                  rcx

// temporary register are r10 and r11
|.define LREG,                  rsi
|.define LREGL,                 esi
|.define RREG,                  rdx
|.define RREGL,                 edx

|.define T1,                    r11
|.define T1L,                   r11d

// registers for normal C function calling ABI
|.define CARG1,                 rdi
|.define CARG2,                 rsi
|.define CARG3,                 rdx
|.define CARG4,                 rcx
|.define CARG5,                 r8
|.define CARG6,                 r9

|.define CARG1L,                edi
|.define CARG2L,                esi
|.define CARG3L,                edx
|.define CARG4L,                ecx
|.define CARG5L,                r8d
|.define CARG6L,                r9d

|.define CARG1LL,               dil
|.define CARG2LL,               sil
|.define CARG3LL,               dl
|.define CARG4LL,               cl
|.define CARG5LL,               r8b
|.define CARG6LL,               r9b

/* ---------------------------------------------------------------
 * debug helper                                                  |
 * --------------------------------------------------------------*/
|.macro Break
|  int 3
|.endmacro

/* ---------------------------------------------------------------
 * dispatch table                                                |
 * --------------------------------------------------------------*/
|.macro Dispatch
|  mov INSTR,dword [PC]
|  movzx OP,INSTR_OP
|  add PC,4
|  jmp aword [DISPATCH+OP*8]
|.endmacro

/* ---------------------------------------------------------------
 * decode each instruction's argument/operand                    |
 * --------------------------------------------------------------*/
|.macro instr_B
|  movzx ARG1,INSTR_A8
|  shr INSTR,16
|.endmacro

|.macro instr_C
|  shr INSTR,8
|  movzx ARG1,INSTR_A16
|  shr INSTR,16
|.endmacro

|.macro instr_D
|  movzx ARG1,INSTR_A8
|  shr INSTR,16
|  movzx ARG3,INSTR_A8
|  shr INSTR,8
|.endmacro

|.macro instr_E
|  movzx ARG1,INSTR_A8
|  shr INSTR,16
|.endmacro

|.macro instr_F
|  movzx ARG1,INSTR_A8
|.endmacro

|.macro instr_G
|  shr INSTR,8
|  movzx ARG1,INSTR_A16
|.endmacro

|.macro instr_X
|.endmacro

|.macro instr_N
|  instr_D
|.endmacro


/* -----------------------------------------------------------
 * constant loading                                          |
 * ----------------------------------------------------------*/

// Currently our constant loading is *slow* due to the design of our GC
// and also the layout of each constant array. I think we have a way to
// optimize away one memory move. LuaJIT's constant loading is just one
// single instruction since they only get one constant array and they don't
// need to worry about GC move the reference
|.macro LdInt,reg,index
|  mov T1,qword [PROTO]
|  mov T1,qword [T1+PrototypeLayout::kIntTableOffset]
|  mov reg, [T1+index*4]
|.endmacro

// TODO:: Optimize this piece of shit
|.macro LdIntV,reg,regL,index
|  mov T1,qword [PROTO]
|  mov T1,qword [T1+PrototypeLayout::kIntTableOffset]

|.if 1
|  mov reg, Value::FLAG_INTEGER
|  shl reg,32
|  or regL,dword [T1+index*4]
|.else
|  mov64 reg, static_cast<std::uint64_t>(Value::TAG_INTEGER)
|  or regL,dword [T1+index*4]
|.endif

|.endmacro

|.macro LdReal,reg,index
|  mov T1,qword [PROTO]
|  mov T1,qword [T1+PrototypeLayout::kRealTableOffset]
|  movsd reg,qword[T1+index*8]
|.endmacro

|.macro LdRealV,reg,index
|  mov T1,qword [PROTO]
|  mov T1,qword [T1+PrototypeLayout::kRealTableOffset]
// not a xmm register
|  mov reg,qword[T1+index*8]
|.endmacro

|.macro LdInt2Real,reg,index
|  mov T1,qword [PROTO]
|  mov T1,qword [T1+PrototypeLayout::kIntTableOffset]
|  cvtsi2sd reg, dword [T1+index*4]
|.endmacro

|.macro StIntACC,reg
|  mov dword [STK+ACCIDX],reg
|  mov dword [STK+ACCFIDX],Value::FLAG_INTEGER
|.endmacro

|.macro StInt,index,reg
|  mov dword [STK+index*8],reg
|  mov dword [STK+index*8+4],Value::FLAG_INTEGER
|.endmacro

|.macro StRealACC,reg
|  movsd qword [ACC],reg
|.endmacro

|.macro CheckNum,index,val,real_label,int_label
|.if 1
|  cmp dword[STK+index*8+4],Value::FLAG_REAL
|  jb >real_label
|  cmp dword[STK+index*8+4],Value::FLAG_INTEGER
|  je >int_label
|.else
|  mov T1,val
|  shr T1,32
|  cmp T1,Value::FLAG_REAL
|  jb >real_label
|  cmp T1,Value::FLAG_INTEGER
|  je >int_label
|.endif
|.endmacro

/* -----------------------------------------------------------
 * Macro Interfaces for Dynasm                               |
 * ----------------------------------------------------------*/
#define Dst (&(bctx->dasm_ctx))

/* -----------------------------------------------------------
 * Interpreter Prolog                                        |
 * ----------------------------------------------------------*/
void GenerateProlog( BuildContext* bctx ) {
  (void)bctx;
}

/* -----------------------------------------------------------
 * helper functions/routines generation                      |
 * ----------------------------------------------------------*/
void GenerateHelper( BuildContext* bctx ) {

  /* ----------------------------------------
   * InterpArithXXX                         |
   * ---------------------------------------*/
  |.macro arith_handle_ret
  |  mov T1,rax
  |  shr T1,32
  |  cmp T1,Value::TAG_NULL
  |  je ->InterpFail
  |  mov qword [ACC], rax
  |  Dispatch
  |.endmacro

  |->InterpArithIntL:
  |  mov CARG1,SANDBOX
  |  LdInt CARG2L,ARG1
  |  fcall InterpreterDoArithmetic
  |  arith_handle_ret

  |->InterpArithIntR:
  |  mov CARG1,SANDBOX
  |  LdInt CARG3L,ARG2
  |  fcall InterpreterDoArithmetic
  |  arith_handle_ret

  |->InterpArithRealL:
  |  mov CARG1,SANDBOX
  |  LdReal xmm0,ARG1
  |  movd CARG2,xmm0
  |  fcall InterpreterDoArithmetic
  |  arith_handle_ret

  |->InterpArithRealR:
  |  mov CARG1,SANDBOX
  |  LdReal xmm0,ARG2
  |  movd CARG3,xmm0
  |  fcall InterpreterDoArithmetic
  |  arith_handle_ret

  |->InterpArithVV:
  |  mov CARG1, SANDBOX
  |  mov CARG2, qword [STK+ARG1*8]
  |  mov CARG3, qword [STK+ARG2*8]
  |  fcall InterpreterDoArithmetic
  |  arith_handle_ret

  |->InterpPowFast:
  |  fcall Pow 
  |  movsd qword [ACC],xmm0
  |  Dispatch

  |->InterpPowSlow:
  |  mov CARG1, SANDBOX
  |  fcall InterpreterPow
  |  arith_handle_ret

  /* -------------------------------------------
   * Interp Arithmetic Exception               |
   * ------------------------------------------*/
  |->DivByZero:
  |  mov CARG1,SANDBOX
  |  mov CARG2,[PC-4]
  |  fcall InterpreterDivByZero
  |  jmp ->InterpFail

  |->ModByReal:
  |  mov CARG1,SANDBOX
  |  mov CARG2,[PC-4]
  |  fcall InterpreterModByReal
  |  jmp ->InterpFail


  /* -------------------------------------------
   * Interpreter exit handler                  |
   * ------------------------------------------*/
  |->InterpFail:
  |  xor rax,rax
  |  epilog
  |  ret

  |->InterpReturn:
  |  mov rax, qword [ACC]
  |  mov qword [SANDBOX+SandboxLayout::kRetOffset],rax
  |  mov rax,1
  |  epilog
  |  ret
}

void GenerateOneBytecode( BuildContext* bctx, Bytecode bc ) {
  // hack around idiv operator which are used to implement the
  // BC_MODXX and BC_DIVXX instruction. It has a different format
  // and different result/output
  bool arith_div = false;
  bool arith_mod = false;

  switch(bc) {
    /** =====================================================
     *  Call handling                                       |
     *  ====================================================*/
    case BC_RETNULL:
      |=> bc:
      |  instr_X
      |  mov dword [STK+ACCFIDX],Value::FLAG_NULL
      |  jmp ->InterpReturn
      break;
    /** =====================================================
     *  Register Move                                       |
     *  ====================================================*/
    case BC_MOVE:
      |=> bc:
      |  instr_E
      |  mov RREG,qword [STK+ARG2*8]
      |  mov qword [STK+ARG1*8],RREG
      |  Dispatch
      break;
    /** =====================================================
     *  Constant Loading                                    |
     *  ====================================================*/
    case BC_LOADI:
      |=> bc:
      |  instr_B
      |  LdInt LREGL,ARG2
      |  StInt ARG1,LREGL
      |  Dispatch
      break;

    case BC_LOAD0:
      |=> bc:
      |  instr_B
      |  StInt ARG1,0
      |  Dispatch
      break;

    case BC_LOAD1:
      |=> bc:
      |  instr_B
      |  StInt ARG1,1
      |  Dispatch
      break;

    case BC_LOADN1:
      |=> bc:
      |  instr_B
      |  StInt ARG1,-1
      |  Dispatch
      break;

    case BC_LOADR:
      |=> bc:
      |  instr_B
      |  LdReal xmm0,ARG2
      |  movsd qword [STK+ARG1*8],xmm0
      |  Dispatch
      break;

    case BC_LOADNULL:
      |=> bc:
      |  instr_F
      |  mov dword [STK+ARG1*8+4],Value::FLAG_NULL
      |  Dispatch
      break;

    case BC_LOADTRUE:
      |=> bc:
      |  instr_F
      |  mov dword [STK+ARG1*8+4],Value::FLAG_TRUE
      |  Dispatch
      break;

    case BC_LOADFALSE:
      |=> bc:
      |  instr_F
      |  mov dword [STK+ARG1*8+4],Value::FLAG_FALSE
      |  Dispatch
      break;

    /** =====================================================
     *  Arith XV                                            |
     *  ====================================================*/
    |.macro arith_xv_pre,BC,SlowPath
    |  instr_C
    |  mov RREG,qword [STK+ARG2*8]
    |  CheckNum ARG2,RREG,1,2
    |  mov CARG4L,BC
    |  jmp ->SlowPath
    |.endmacro

    |.macro arith_iv_real,instr
    |  LdInt2Real xmm0,ARG1
    |  movd xmm1,RREG
    |  instr xmm0,xmm1
    |  StRealACC xmm0
    |  Dispatch
    |.endmacro

    |.macro arith_rv_real,instr
    |  LdReal xmm0,ARG1
    |  movd xmm1,RREG
    |  instr xmm0,xmm1
    |  StRealACC xmm0
    |  Dispatch
    |.endmacro

    |.macro arith_iv_int,instr
    |  LdInt LREGL,ARG1
    || if( arith_div ) {
    |    mov eax,LREGL

    |.if 1
    |    test RREGL,RREGL
    |    je ->DivByZero
    |.endif

    |    idiv RREGL
    |    StIntACC eax
    || } else if( arith_mod ) {
    |    mov eax,LREGL
    |.if 1
    |    test RREGL,RREGL
    |    je ->DivByZero
    |.endif
    |    idiv RREGL
    |    StIntACC edx
    || } else {
    |    instr LREGL,RREGL
    |    StIntACC LREGL
    || }
    |  Dispatch
    |.endmacro

    |.macro arith_rv_int,instr
    |  LdReal xmm0,ARG1
    |  cvtsi2sd xmm1, RREGL
    |  instr xmm0,xmm1
    |  StRealACC xmm0
    |  Dispatch
    |.endmacro

    case BC_ADDIV:
      |=> bc:
      |  arith_xv_pre BC_ADDIV,InterpArithIntL
      |1:
      |  arith_iv_real,addsd
      |2:
      |  arith_iv_int,add
      break;

    case BC_ADDRV:
      |=>bc:
      |  arith_xv_pre BC_ADDRV,InterpArithRealL
      |1:
      |  arith_rv_real,addsd
      |2:
      |  arith_rv_int,addsd
      break;

    case BC_SUBIV:
      |=>bc:
      |  arith_xv_pre BC_SUBIV,InterpArithIntL
      |1:
      |  arith_iv_real,subsd
      |2:
      |  arith_iv_int ,sub
      break;

    case BC_SUBRV:
      |=>bc:
      |  arith_xv_pre BC_SUBRV,InterpArithRealL
      |1:
      |  arith_rv_real,subsd
      |2:
      |  arith_rv_int ,subsd
      break;

    case BC_MULIV:
      |=>bc:
      |  arith_xv_pre BC_MULIV,InterpArithIntL
      |1:
      |  arith_iv_real,mulsd
      |2:
      |  arith_iv_int,imul
      break;

    case BC_MULRV:
      |=>bc:
      |  arith_xv_pre BC_MULRV,InterpArithRealL
      |1:
      |  arith_rv_real,mulsd
      |2:
      |  arith_rv_int,mulsd
      break;

    case BC_DIVIV:
      arith_div = true;
      |=>bc:
      |  arith_xv_pre BC_DIVIV,InterpArithIntL
      |1:
      |  arith_iv_real,mulsd
      |2:
      |  arith_iv_int,imul
      break;

    case BC_DIVRV:
      arith_div = true;
      |=>bc:
      |  arith_xv_pre BC_DIVRV,InterpArithRealL
      |1:
      |  arith_rv_real,divsd
      |2:
      |  arith_rv_int,divsd
      break;

    case BC_MODIV:
      arith_mod = true;
      |=>bc:
      |  arith_xv_pre BC_MODIV,InterpArithIntL
      |1:
      |  jmp ->ModByReal
      |2:
      |  arith_iv_int,imul
      break;

    /* =========================================================
     * Arith VX                                                |
     * ========================================================*/
    |.macro arith_vx_pre,BC,SlowPath
    |  instr_B
    |  mov LREG,qword [STK+ARG1*8]
    |  CheckNum ARG1,LREG,1,2
    |  mov CARG4L,BC
    |  jmp ->SlowPath
    |.endmacro

    |.macro arith_vi_real,instr
    |  LdInt2Real xmm1,ARG2
    |  movd xmm0,LREG
    |  instr xmm0,xmm1
    |  StRealACC xmm0
    |  Dispatch
    |.endmacro

    |.macro arith_vi_int,instr
    |  LdInt RREGL,ARG2
    || if( arith_div ) {
    |    mov edx,LREGL

    |.if 1
    |    test RREGL,RREGL
    |    jmp ->DivByZero
    |.endif

    |    idiv RREGL
    |    StIntACC eax
    || } else if(arith_mod) {
    |    mov edx,LREGL

    |.if 1
    |    test RREGL,RREGL
    |    jmp ->DivByZero
    |.endif

    |    idiv RREGL
    |    StIntACC edx
    || } else {
    |    instr LREGL,RREGL
    |    StIntACC LREGL
    || }
    |  Dispatch
    |.endmacro

    |.macro arith_vr_real,instr
    |  LdReal xmm1, ARG2
    |  movd xmm0,LREG
    |  instr xmm0,xmm1
    |  StRealACC xmm0
    |  Dispatch
    |.endmacro

    |.macro arith_vr_int,instr
    |  LdReal xmm1,ARG2
    |  cvtsi2sd xmm0, LREGL
    |  instr xmm0,xmm1
    |  StRealACC xmm0
    |  Dispatch
    |.endmacro

    case BC_ADDVI:
      |=> bc:
      |  arith_vx_pre BC_ADDVI,InterpArithIntR
      |1:
      |  arith_vi_real addsd
      |2:
      |  arith_vi_int  add
      break;

    case BC_ADDVR:
      |=> bc:
      |  arith_vx_pre BC_ADDVR,InterpArithRealR
      |1:
      |  arith_vr_real addsd
      |2:
      |  arith_vr_int addsd
      break;

    case BC_SUBVI:
      |=> bc:
      |  arith_vx_pre BC_SUBVI,InterpArithIntR
      |1:
      |  arith_vi_real subsd
      |2:
      |  arith_vi_int sub
      break;

    case BC_SUBVR:
      |=> bc:
      |  arith_vx_pre BC_SUBVR,InterpArithRealR
      |1:
      |  arith_vr_real subsd
      |2:
      |  arith_vr_int subsd
      break;

    case BC_MULVI:
      |=> bc:
      |  arith_vx_pre BC_MULVI,InterpArithIntR
      |1:
      |  arith_vi_real mulsd
      |2:
      |  arith_vi_int imul
      break;

    case BC_MULVR:
      |=> bc:
      |  arith_vx_pre BC_MULVR,InterpArithRealR
      |1:
      |  arith_vr_real mulsd
      |2:
      |  arith_vr_real mulsd
      break;

    case BC_DIVVI:
      |=> bc:
      arith_div = true;
      |  arith_vx_pre BC_DIVVI,InterpArithIntR
      |1:
      |  arith_vi_real divsd
      |2:
      |  arith_vi_int sub
      break;

    case BC_DIVVR:
      |=> bc:
      |  arith_vx_pre BC_DIVVR,InterpArithRealR
      |1:
      |  arith_vr_real divsd
      |2:
      |  arith_vr_int divsd
      break;

    case BC_MODVI:
      arith_mod = true;
      |=> bc:
      |  arith_vx_pre BC_MODVI,InterpArithIntR
      |1:
      |  jmp ->ModByReal
      |2:
      |  arith_vi_int imul
      break;

    /* ========================================================
     * ArithVV
     *
     * The arithVV is also optimized for common path here.
     * We inline all numeric calculation cases, int/real.
     * Other cases will be pushed back to call C++ function
     * which may be extended to support meta function call
     * ========================================================*/

    // perform VV calaculation based on instruction
    |.macro arith_vv,BC,instrI,setterI,instrR,setterR
    |  instr_D
    |  mov LREGL,dword[STK+ARG1*8+4]
    |  mov RREGL,dword[STK+ARG2*8+4]

    // here we will do a type check and also promotion
    |  cmp LREGL,Value::FLAG_INTEGER
    |  je >1
    |  cmp RREGL,Value::FLAG_REAL
    |  jb >2
    |  jmp >6 // cannot handle

    |1:
    |  cmp RREGL,Value::FLAG_INTEGER
    |  je >4 // int && int
    |  cmp RREGL,Value::FLAG_REAL
    |  jnb >6 // cannot handle

    // promoting LHS->real
    |  cvtsi2sd xmm0,dword [STK+ARG1*8]
    |  instrR xmm0,qword [STK+ARG2*8]
    |  setterR xmm0
    |  Dispatch

    |2:
    |  cmp RREGL,Value::FLAG_REAL
    |  jb >5  // real && real
    |  cmp RREGL,Value::FLAG_INTEGER
    |  jne >6 // cannot handle
    // promoting RHS->real
    |  cvtsi2sd xmm1,dword [STK+ARG2*8]
    |  movsd xmm0,qword [STK+ARG1*8]
    |  setterR xmm0
    |  Dispatch

    // int && int
    |4:
    || if( arith_div ) {
    |    mov edx,dword [STK+ARG1*8]
    |    idiv dword [STK+ARG2*8]
    |    setterI eax
    || } else if (arith_mod) {
    |    mov edx,dword [STK+ARG1*8]
    |    idiv dword [STK+ARG2*8]
    |    setterI edx
    || } else {
    |    mov LREGL,dword [STK+ARG1*8]
    |    instrI LREGL,dword [STK+ARG2*8]
    |    setterI LREGL
    || }
    |  Dispatch

    // real && real
    |5:
    || if( arith_mod ) {
    |    jmp ->ModByReal
    || } else {
    |    movsd xmm0,qword [STK+ARG1*8]
    |    instrR xmm0,qword [STK+ARG2*8]
    |    setterR xmm0
    || }
    |  Dispatch

    // slow path
    |6:
    |  mov CARG4L,BC
    |  jmp ->InterpArithVV

    |.endmacro

    case BC_ADDVV:
      |=> bc:
      |  arith_vv BC_ADDVV,add,StIntACC,addsd,StRealACC
      break;
    case BC_SUBVV:
      |=> bc:
      |  arith_vv BC_SUBVV,sub,StIntACC,subsd,StRealACC
      break;
    case BC_MULVV:
      |=> bc:
      |  arith_vv BC_MULVV,imul,StIntACC,mulsd,StRealACC
      break;
    case BC_DIVVV:
      arith_div = true;
      |=> bc:
      |  arith_vv BC_DIVVV,imul,StIntACC,divsd,StRealACC
      break;
    case BC_MODVV:
      arith_mod = true;
      |=> bc:
      |  arith_vv BC_MODVV,imul,StIntACC,divsd,StRealACC
      break;

    /* ==========================================================
     * POW part
     *
     * Currently we directly use std::pow/pow in libc for simplicity.
     * For numeric type we will directly call pow for other types
     * we will fallback to slow C++ function
     * =========================================================*/

    |.macro pow_promo,REGL,XREG,ARG
    |  mov REGL,dword [STK+ARG*8+4]
    |  cmp REGL,Value::FLAG_REAL
    |  jb >1
    |  cmp REGL,Value::FLAG_INTEGER
    |  jne >2
    |  cvtsi2sd XREG,qword [STK+ARG*8]
    |.endmacro

    case BC_POWIV:
      |=> bc:
      |  instr_C
      |  LdInt2Real,xmm0,ARG1
      |  pow_promo,RREGL,xmm1,ARG2
      |1:
      |  jmp ->InterpPowFast
      |2:
      |  LdIntV CARG2,CARG2L,ARG1
      |  mov CARG3, qword [STK+ARG2*8]
      |  mov CARG4, BC_POWIV
      |  jmp ->InterpPowSlow
      break;

    case BC_POWVI:
      |=> bc:
      |  instr_B
      |  LdInt2Real,xmm1,ARG2
      |  pow_promo,LREGL,xmm0,ARG1
      |1:
      |  jmp ->InterpPowFast
      |2:
      |  mov CARG2, qword [STK+ARG1*8]
      |  LdIntV CARG3,CARG3L,ARG2
      |  mov CARG4, BC_POWVI
      |  jmp ->InterpPowSlow
      break;

    case BC_POWRV:
      |=> bc:
      |  instr_C
      |  LdReal xmm0,ARG1
      |  pow_promo RREGL,xmm1,ARG2
      |1:
      |  jmp ->InterpPowFast
      |2:
      |  LdRealV CARG2,ARG1
      |  mov CARG3,qword [STK+ARG2*8]
      |  mov CARG4,BC_POWRV
      |  jmp ->InterpPowSlow
      break;

    case BC_POWVR:
      |=> bc:
      |  instr_C
      |  LdReal xmm1,ARG2
      |  pow_promo LREGL,xmm0,ARG1
      |1:
      |  jmp ->InterpPowFast
      |2:
      |  LdRealV CARG3,ARG2
      |  mov CARG2,qword [STK+ARG1*8]
      |  mov CARG4,BC_POWVR
      |  jmp ->InterpPowSlow
      break;

    case BC_POWVV:
      |=> bc:
      |  instr_C
      |  mov CARG2,qword [STK+ARG1*8]
      |  mov CARG3,qword [STK+ARG2*8]
      |  mov CARG4,BC_POWVV
      |  jmp ->InterpPowSlow
      break;
    default:
      |=> bc:
      |  nop
      break;
  }
}

// Help Dasm to resolve external address via Index idx
int ResolveExternAddress( void** ctx , unsigned char* addr ,
                                       int idx,
                                       int type ) {
  (void)ctx;
  void* ptr;
  if(strcmp(extnames[idx],"Pow")==0) {
    ptr = reinterpret_cast<void*>(&Pow);
  } else if(strcmp(extnames[idx],"InterpreterModByReal")==0) {
    ptr = reinterpret_cast<void*>(&InterpreterModByReal);
  } else if(strcmp(extnames[idx],"InterpreterDivByZero")==0) {
    ptr = reinterpret_cast<void*>(&InterpreterDivByZero);
  } else if(strcmp(extnames[idx],"InterpreterPow")==0) {
    ptr = reinterpret_cast<void*>(&InterpreterPow);
  } else if(strcmp(extnames[idx],"InterpreterDoArithmetic")==0) {
    ptr = reinterpret_cast<void*>(&InterpreterDoArithmetic);
  } else {
    lava_unreach("WHY!");
  }

  lava_verify(CheckAddress(reinterpret_cast<std::uintptr_t>(ptr)));

  if(type) {
    return (int)((reinterpret_cast<unsigned char*>(ptr) - (addr+4)));
  } else {
    return (int)(reinterpret_cast<std::uintptr_t>(ptr));
  }
}

void Disassemble( Interpreter* interp ) {
  DumpWriter writer;
  std::size_t length = interp->code_size;
  void* buffer = reinterpret_cast<void*>(interp->entry);

  ZydisDecoder decoder;
  ZydisDecoderInit(
      &decoder,
      ZYDIS_MACHINE_MODE_LONG_64,
      ZYDIS_ADDRESS_WIDTH_64);

  ZydisFormatter formatter;
  ZydisFormatterInit(&formatter,ZYDIS_FORMATTER_STYLE_INTEL);

  std::uint64_t pc = reinterpret_cast<std::uint64_t>(buffer);
  std::uint8_t* rp = static_cast<std::uint8_t*>(buffer);
  std::size_t size = length;

  ZydisDecodedInstruction instr;
  while(ZYDIS_SUCCESS(
        ZydisDecoderDecodeBuffer(&decoder,rp,size,pc,&instr))) {
    char buffer[256];
    ZydisFormatterFormatInstruction(
        &formatter,&instr,buffer,sizeof(buffer));

    for( std::size_t i = 0 ; i < SIZE_OF_BYTECODE ; ++i ) {
      void* p = reinterpret_cast<void*>(pc);
      if(p == interp->dispatch_interp[i]) {
        writer.WriteL("===> Bytecode : %s",GetBytecodeName(
              static_cast<Bytecode>(i)));
        break;
      }
    }

    writer.WriteL("%016" PRIX64 " " "%s",pc,buffer);
    rp += instr.length;
    size -= instr.length;
    pc += instr.length;
  }

}

// We directly allocate a chunk of memory and *let it leak*
void BuildInterpreter( Interpreter* interp ) {
  BuildContext bctx;
  // initialize dasm_State object
  dasm_init(&(bctx.dasm_ctx),1);

  // setup the freaking global
  void* glb_arr[GLBNAME__MAX];
  dasm_setupglobal(&(bctx.dasm_ctx),glb_arr,GLBNAME__MAX);

  // setup the dasm
  dasm_setup(&(bctx.dasm_ctx),actions);

  // initialize the tag value needed , at least for each BC we need one
  dasm_growpc(&(bctx.dasm_ctx), SIZE_OF_BYTECODE);

  // build the prolog
  GenerateProlog(&bctx);

  // build the helper
  GenerateHelper(&bctx);

  // generate all bytecode's routine
  for( int i = static_cast<int>(BC_ADDIV) ; i < SIZE_OF_BYTECODE ; ++i ) {
    GenerateOneBytecode(&bctx,static_cast<Bytecode>(i));
  }

  std::size_t code_size;
  lava_verify(dasm_link(&(bctx.dasm_ctx),&code_size) ==0);

  // generate a buffer and set the proper protection field for that piece of
  // memory to make our code *work*
  std::size_t new_size;
  void* buffer = OS::CreateCodePage(code_size,&new_size);
  lava_verify(buffer);

  // encode the assembly code into the buffer
  dasm_encode(&(bctx.dasm_ctx),buffer);

  // get all pc labels for entry of bytecode routine
  for( int i = static_cast<int>(BC_ADDIV) ; i < SIZE_OF_BYTECODE ; ++i ) {
    int off = dasm_getpclabel(&(bctx.dasm_ctx),static_cast<Bytecode>(i));
    interp->dispatch_interp[i] =
      reinterpret_cast<void*>(static_cast<char*>(buffer) + off);
  }

  interp->entry = reinterpret_cast<Interpret>(buffer);
  interp->buffer_size = new_size;
  interp->code_size   = code_size;

  // now we try a disassemble to see whether our shit actually looks Okay
  {
    DumpWriter writer(NULL);
    Disassemble(interp);
  }

  dasm_free(&(bctx.dasm_ctx));
}

} // namespace

void GenerateInterpreter( Interpreter* interp ) {
  BuildInterpreter(interp);
}

} // namespace lavascript
} // namespace interpreter
