#include "bytecode-interpreter.h"
#include "interpreter-frame.h"
#include "interpreter-runtime.h"

#include "src/context.h"
#include "src/trace.h"
#include "src/os.h"
#include "src/config.h"

#include <algorithm>
#include <map>
#include <cassert>
#include <climits>
#include <Zydis/Zydis.h>

// This the C symbol we use to resolve certain runtime function. Ideally these
// functions *should* be replaced with carefully tuned inline assembly but we
// could just call this out for current phase/stage. Later on to work at better
// version of these functions
extern "C" {
double pow(double,double);
} // extern "C"

namespace lavascript {
namespace interpreter{

inline void SetValueFlag( Value* v , std::uint32_t flag ) {
  v->raw_ = static_cast<std::uint64_t>(flag) << 32;
}

inline std::uint32_t GetValueFlag( const Value& v ) {
  return static_cast<std::uint32_t>(v.raw_ >>32);
}

namespace {

// Used in dynasm library
int ResolveExternAddress( void**,unsigned char*,int,int );

// Workaround for ODR
#include "dep/dynasm/dasm_proto.h"

#define DASM_EXTERN_FUNC(a,b,c,d) ResolveExternAddress((void**)a,b,c,d)
#include "dep/dynasm/dasm_x86.h"

// -------------------------------------------------------------
// BuildContext
//
// Build phase context, used to *generate* templated interpreter
// -------------------------------------------------------------
struct BuildContext {
  dasm_State* dasm_ctx;
  int tag;

  BuildContext():
    dasm_ctx(NULL),
    tag(0)
  {}

  ~BuildContext() {
    if(dasm_ctx) dasm_free(&dasm_ctx);
  }
};


// Shut the GCC's mouth fucked up
template< typename T >
int HorribleCast( T* ptr ) {
  std::uint64_t iptr = reinterpret_cast<std::uint64_t>(ptr);
  int ret = static_cast<int>(iptr);
  lava_verify(reinterpret_cast<T*>(ret) == ptr);
  return ret;
}


// ------------------------------------------------------------------
// Prototype for the main interpreter function
//
// @ARG1: runtime
// @ARG2: Prototype** of the function
// @ARG3: start of the stack
// @ARG4: start of the code buffer for the *Prototype*
// @ARG5: start of the dispatch table
typedef bool (*Main)(Runtime*,Prototype**,void*,void*,void*);

// ------------------------------------------------------------------
// Helper function/macros to register its literal name into a global
// table to help resolve the function's address during assembly link
// phase
// ------------------------------------------------------------------
typedef std::map<std::string,void*> ExternSymbolTable;

ExternSymbolTable* GetExternSymbolTable() {
  static ExternSymbolTable kTable;
  return &kTable;
}

// Macro to register a external function's symbol name into global table
#define INTERPRETER_REGISTER_EXTERN_SYMBOL(XX)                               \
  struct XX##_Registry {                                                     \
    XX##_Registry() {                                                        \
      ExternSymbolTable* table = GetExternSymbolTable();                     \
      table->insert(std::make_pair(#XX,reinterpret_cast<void*>(&XX)));       \
    }                                                                        \
  };                                                                         \
  static XX##_Registry k##XX##_Registry;


// ------------------------------------------------------------------
// Builtin libc function exposure section
// ------------------------------------------------------------------
INTERPRETER_REGISTER_EXTERN_SYMBOL(pow)


// -------------------------------------------------------------------
// Helper to set Value object to indicate special meaning
// -------------------------------------------------------------------
#define VALUE_FAIL Value::FLAG_1

/* --------------------------------------------------------------------------
 *
 * Interpreter C++ Part Function Implementation
 *
 * -------------------------------------------------------------------------*/
inline Bytecode PrevOpcode( Runtime* sandbox ) {
  std::uint32_t pbc = sandbox->cur_pc[-1];
  return static_cast<Bytecode>( pbc & 0xff );
}

// --------------------------------------------------------------------------
// Arithmetic Helper
// --------------------------------------------------------------------------
Value InterpreterDoArithmetic( Runtime* sandbox ,
                               Value left ,
                               Value right ) {
  (void)sandbox;
  (void)left;
  (void)right;
  {
    Value r;
    SetValueFlag( &r, VALUE_FAIL );
    return r;
  }
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoArithmetic)

Value InterpreterPow         ( Runtime* sandbox ,
                               Value left,
                               Value right ,
                               Value* output ) {
  (void)sandbox;
  (void)left;
  (void)right;
  (void)output;
  {
    Value r;
    SetValueFlag( &r, VALUE_FAIL );
    return r;
  }
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPow)

void InterpreterDivByZero    ( Runtime* sandbox , std::uint32_t* pc ) {
  (void)sandbox;
  (void)pc;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDivByZero)


// ---------------------------------------------------------------------------
// Comparison Helper
// ---------------------------------------------------------------------------
Value InterpreterDoCompare  ( Runtime* sandbox , Value left ,
                                                 Value right ) {
  (void)sandbox;
  (void)left;
  (void)right;
  {
    Value r;
    SetValueFlag( &r, VALUE_FAIL );
    return r;
  }
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoCompare)

// ----------------------------------------------------------------------------
// Unary Helper
// ----------------------------------------------------------------------------
bool InterpreterDoNegate   ( Runtime* sandbox , const Value& operand ,
                                                Value* result ) {
  (void)sandbox;
  (void)operand;
  (void)result;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoNegate)

// ----------------------------------------------------------------------------
// Jump Helper
// ----------------------------------------------------------------------------
void* InterpreterDoCondJmpT  ( Runtime* sandbox , Value condition ,
                                                  std::uint32_t where ,
                                                  void* start_of_pc ) {
  (void)sandbox;
  (void)condition;
  (void)where;
  (void)start_of_pc;
  return NULL;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoCondJmpT)

void* InterpreterDoCondJmpF  ( Runtime* sandbox , Value condition ,
                                                  std::uint32_t where ,
                                                  void* start_of_pc ) {
  (void)sandbox;
  (void)condition;
  (void)where;
  (void)start_of_pc;
  return NULL;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoCondJmpF)


void* InterpreterDoCondAnd   ( Runtime* sandbox , Value condition ,
                                                  std::uint32_t where ,
                                                  void* start_of_pc ) {
  (void)sandbox;
  (void)condition;
  (void)where;
  (void)start_of_pc;
  return NULL;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoCondAnd)

void* InterpreterDoCondOr    ( Runtime* sandbox , Value condition ,
                                                  std::uint32_t where ,
                                                  void* start_of_pc ) {
  (void)sandbox;
  (void)condition;
  (void)where;
  (void)start_of_pc;
  return NULL;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoCondOr)

// ----------------------------------------------------------------------------
// Literal Loader Helper
// ----------------------------------------------------------------------------
bool InterpreterDoLoadList0  ( Runtime* sandbox , Value* output ) {
  (void)sandbox;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadList0)

bool InterpreterDoLoadList1  ( Runtime* sandbox , Value* output ,
                                                  Value e1 ) {
  (void)sandbox;
  (void)output;
  (void)e1;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadList1)

bool InterpreterDoLoadList2  ( Runtime* sandbox , Value* output ,
                                                  Value e1,
                                                  Value e2 ) {
  (void)sandbox;
  (void)output;
  (void)e1;
  (void)e2;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadList2)

bool InterpreterDoNewList   ( Runtime* sandbox , Value* output ,
                                                  std::uint32_t narg ) {
  (void)sandbox;
  (void)output;
  (void)narg;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoNewList)

bool InterpreterDoAddList   ( Runtime* sandbox , Value* output ,
                                                 Value  val ) {
  (void)sandbox;
  (void)output;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoAddList)

bool InterpreterDoLoadObj0   ( Runtime* sandbox , Value* output ) {
  (void)sandbox;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadObj0)

bool InterpreterDoLoadObj1   ( Runtime* sandbox , Value* output ,
                                                  Value  key,
                                                  Value  val ) {
  (void)sandbox;
  (void)output;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadObj1)

bool InterpreterDoNewObj    ( Runtime* sandbox , Value* output ,
                                                 std::uint32_t narg ) {
  (void)sandbox;
  (void)output;
  (void)narg;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoNewObj)

bool InterpreterDoAddObj    ( Runtime* sandbox , Value* output ,
                                                 Value  key,
                                                 Value  val ) {
  (void)sandbox;
  (void)output;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoAddObj)

bool InterpreterDoLoadCls   ( Runtime* sandbox , Value* start_of_stack ,
                                                 std::uint32_t prototype_id ,
                                                 Value* dest ) {
  (void)sandbox;
  (void)start_of_stack;
  (void)prototype_id;
  (void)dest;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadCls)

// ----------------------------------------------------------------------------
// Property Get/Set
// ----------------------------------------------------------------------------
Value InterpreterDoPropGet   ( Runtime* sandbox , Value obj , String** key ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  {
    Value r;
    SetValueFlag( &r, VALUE_FAIL );
    return r;
  }
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoPropGet)

void InterpreterPropGetNotFound( Runtime* sandbox , Value obj , String** key ) {
  (void)sandbox;
  (void)obj;
  (void)key;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPropGetNotFound)

void InterpreterPropGetNotObject( Runtime* sandbox, Value obj , String** key ) {
  (void)sandbox;
  (void)obj;
  (void)key;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPropGetNotObject)

bool InterpreterDoPropSet      ( Runtime* sandbox , Value obj , String** key ,
                                                                Value val ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoPropSet)

Value InterpreterDoIdxGet      ( Runtime* sandbox , Value obj , Value key ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  {
    Value r;
    SetValueFlag( &r, VALUE_FAIL );
    return r;
  }
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoIdxGet)

Value InterpreterDoIdxGetI     ( Runtime* sandbox , Value obj , std::int32_t idx ) {
  (void)sandbox;
  (void)obj;
  (void)idx;
  {
    Value r;
    SetValueFlag( &r, VALUE_FAIL );
    return r;
  }
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoIdxGetI)

bool InterpreterDoIdxSet      ( Runtime* sandbox , Value obj , Value key ,
                                                               Value val ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoIdxSet)

bool InterpreterDoGGet       ( Runtime* sandbox , Value* output , String** key ) {
  (void)sandbox;
  (void)key;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoGGet)

bool InterpreterDoGSet       ( Runtime* sandbox , String** key , Value value ) {
  (void)sandbox;
  (void)key;
  (void)value;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoGSet)


// ----------------------------------------------------------------------------
// Loop
// ----------------------------------------------------------------------------
bool InterpreterForEnd1     ( Runtime* sandbox , const Value& lhs , const Value& rhs ,
                                                                    std::uint32_t offset ) {
  (void)sandbox;
  (void)lhs;
  (void)rhs;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterForEnd1)

bool InterpreterForEnd2     ( Runtime* sandbox , const Value& lhs , const Value& rhs ,
                                                                    const Value& cond ,
                                                                    std::uint32_t offset ) {
  (void)sandbox;
  (void)lhs;
  (void)rhs;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterForEnd2)


/* ---------------------------------------------------------------------
 *
 * Implementation of AssemblyIntepreter
 *
 * --------------------------------------------------------------------*/
|.arch x64
|.actionlist actions
|.globals GLBNAME_
|.globalnames glbnames
|.externnames extnames
|.section code,data

/* -------------------------------------------------------------------
 * Preprocessor option for dynasm
 * ------------------------------------------------------------------*/
|.define CHECK_DIV_BY_ZERO
|.define CHECK_NUMBER_MEMORY,0
|.define TRACE_OP,0
|.define USE_CMOV_COMP,0
|.define USE_CMOV_NEG

/* -------------------------------------------------------------------
 * 64 bits call
 *
 * Since 64 bits call cannot accept a imm value due to it is too long,
 * we need to generate different *types* of call instruction based on
 * the callsite
 * -------------------------------------------------------------------*/
inline bool CheckAddress( std::uintptr_t addr ) {
  static const std::uintptr_t k2G = 0x80000000;
  if(addr > 0 && addr < k2G)
    return true;
  else
    return false;
}

|.macro fcall,FUNC
|| if(CheckAddress(reinterpret_cast<std::uintptr_t>(FUNC))) {
|    call extern FUNC
|| } else {
||   lava_warn("%s","Function FUNC address is not in 0-2GB");
|.if 0
// I don't know whether this is faster than use rax , need profile. I see
// this one is used in MoarVM. It uses memory address to work araoud the
// address space problem. But I am kind of unsure about it since it maybe
// because MoarVM already allocate rax for other things
|9:
|.dword (std::uint32_t)((std::uintptr_t)(FUNC)),(std::uint32_t)((std::uintptr_t)((FUNC)>>32))
|    call qword[<9]
|.else
|    mov64 rax, reinterpret_cast<std::uintptr_t>(FUNC)
|    call rax
|.endif
|| }
|.endmacro

/* ---------------------------------------------------------------
 * summary of register usage                                     |
 * --------------------------------------------------------------*/
// Runtime pointer
|.define RUNTIME,               r12   // callee saved

// Current prototype's GCRef pointer
|.define PROTO,                 r13   // callee saved

// Top stack's pointer
|.define STK,                   r14   // callee saved
|.define ACCIDX,                2040
|.define ACCFIDX,               2044
|.define ACCFHIDX,              2046  // for heap flag
|.define ACC,                   STK+ACCIDX

// Dispatch table pointer
|.define DISPATCH,              r15  // callee saved

// Bytecode array
|.define PC,                    rbp  // callee saved

// Hold the decoded unit
|.define INSTR,                 eax
|.define INSTR_OP,              al
|.define INSTR_A8L,             al
|.define INSTR_A8H,             ah
|.define INSTR_A16,             ax

// Frame -------------------------------------------------------
// We store the frame sizeof(IFrame) above STK pointer
static_assert( sizeof(IFrame) == 16 );
|.define CFRAME,                STK-16
|.define FRAMELEN,              16

// Instruction's argument
|.define ARG1_8,                bl
|.define ARG1_16,               bx
|.define ARG1,                  ebx  // must *not* be 64 bits due to we use ah and it MUST be callee saved
|.define ARG1F,                 rbx

// Used to help decode function's call argument
|.define FARG,                  ebx  // aliased with ARG1
|.define FARG16,                bx
|.define FARG8L,                bl
|.define FARG8H,                bh

|.define ARG2_8,                al
|.define ARG2_16,               ax
|.define ARG2,                  eax
|.define ARG2F,                 rax

|.define ARG3_8,                cl
|.define ARG3_16,               cx
|.define ARG3,                  ecx
|.define ARG3F,                 rcx

// temporarily alias OP to be ARG3 because during the
// decoding time , we don't need to hold anything there
|.define OP,                    rcx

// temporary register are r10 and r11
|.define LREG,                  rsi
|.define LREGL,                 esi
|.define RREG,                  rdx
|.define RREGL,                 edx

// absolute safe temporary variables
//
//
// In most places , prefer T0 as temporary register if ARGX
// is not free since it doesn't require REX encoding. But it
// alias with CARG1 , use with cautious
|.define T0,                    rdi
|.define T0L,                   edi
|.define T0L16,                 di

|.define T1,                    r11
|.define T1L,                   r11d
|.define T1L16,                 r11w

|.define T2,                    r10
|.define T2L,                   r10d
|.define T2L16,                 r10w

// registers for normal C function calling ABI
|.define CARG1,                 rdi
|.define CARG2,                 rsi    // LREG
|.define CARG3,                 rdx    // RREG
|.define CARG4,                 rcx
|.define CARG5,                 r8
|.define CARG6,                 r9

|.define CARG1L,                edi
|.define CARG2L,                esi
|.define CARG3L,                edx
|.define CARG4L,                ecx
|.define CARG5L,                r8d
|.define CARG6L,                r9d

|.define CARG1LL,               dil
|.define CARG2LL,               sil
|.define CARG3LL,               dl
|.define CARG4LL,               cl
|.define CARG5LL,               r8b
|.define CARG6LL,               r9b

// saved callee registers plus some other important stuff
// 72 = 64 + (8 padding for function call)
|.define RESERVE_RSP,           72
|.define SAVED_RBX,             [rsp+48]
|.define SAVED_R12,             [rsp+40]
|.define SAVED_R13,             [rsp+32]
|.define SAVED_R14,             [rsp+24]
|.define SAVED_R15,             [rsp+16]
|.define SAVED_RBP,             [rsp+8]

// DO NOT MODIFY IT UNLESS YOU KNOW SHIT
|.define SAVED_PPC,             rsp
|.define SAVED_PC ,             [rsp]

// Used to save certain registers while we call cross the function
// boundary. Like we may call into ToBoolean function to get value
// of certain register's Boolean value and we may need to save register
// like rax which is part of our argument/operand of isntructions
|.define SAVED_SLOT1,           [rsp+56]
|.define SAVED_SLOT2,           [rsp+64]

/* ---------------------------------------------------------------
 * debug helper                                                  |
 * --------------------------------------------------------------*/
|.macro Break
|  int 3
|.endmacro

void PrintOP( int op ) {
  lava_error("OP:%s",GetBytecodeName(static_cast<Bytecode>(op)));
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(PrintOP)

void Print2( int a , int b ) {
  lava_error("L:%d,R:%d",a,b);
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(Print2)

void PrintF( double v ) {
  lava_error("Value:%f",v);
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(PrintF)

void Print64( std::uint64_t a , std::uint64_t b ) {
  lava_error("%" LAVA_FMTU64 ":%" LAVA_FMTU64,a,b);
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(Print64)

/* ---------------------------------------------------------------
 * dispatch table                                                |
 * --------------------------------------------------------------*/
|.macro Dispatch
|.if TRACE_OP
|  mov INSTR,dword [PC]
|  movzx OP,INSTR_OP
|  mov CARG1,OP
|  fcall PrintOP
|.endif
// IFETCH starts, one of the hottest code segement
// The top 4 instructions are ordered as 4-1-1-1 to optimize decoder so
// it can be decoded in one cycle.
|  mov INSTR,dword [PC]  // 2 uops
|  movzx OP,INSTR_OP     // 1 uops
|  add PC,4              // fused 1uops
|  shr INSTR,8           // fused 1uops
|  jmp aword [DISPATCH+OP*8]
|.endmacro

/* ---------------------------------------------------------------
 * decode each instruction's argument/operand                    |
 * --------------------------------------------------------------*/

|.macro instr_B
// cannot use ARG1F due to INSTR_A8 uses ah
|  movzx ARG1F,INSTR_A8L
|  shr INSTR,8
|.endmacro

|.macro instr_C
|  movzx ARG1F,INSTR_A16
|  shr INSTR,16
|.endmacro

|.macro instr_D
|  movzx ARG1F,INSTR_A8L
|  shr INSTR,8
// do not change ARG3 --> ARG3F even if it is better, due to the fact
// we cannot use ax register when rex prefix is used in instruction.
|  movzx ARG3,INSTR_A8H
|  and ARG2,0xff
|.endmacro

|.macro instr_E
|  movzx ARG1,INSTR_A8L
|  shr INSTR,8
|.endmacro

|.macro instr_F
|  movzx ARG1,INSTR_A8L
|.endmacro

|.macro instr_G
|  movzx ARG1F,INSTR_A16
|.endmacro

|.macro instr_X
|.endmacro

|.macro instr_N
|  instr_D
|.endmacro

/* -----------------------------------------------------------
 * Special Constant for Real                                 |
 * ----------------------------------------------------------*/
|.macro LdRConstH,XREG,HIGH
|  mov64 T1,(static_cast<std::uint64_t>(HIGH)<<32)
|  movd XREG,T1
|.endmacro

|.macro LdRConstL,XREG,LOW
|  mov64 T1,(static_cast<std::uint64_t>(LOW))
|  movd XREG,T1
|.endmacro

|.macro LdRConst,XREG,X64V
|  mov64 T1,X64V
|  movd  XREG,T1
|.endmacro

// Used to negate the double precision number's sign bit
|.macro LdRConst_sign,XREG; LdRConstH XREG,0x80000000; .endmacro
|.macro LdRConst_one ,XREG; LdRConstH XREG,0x3ff00000; .endmacro
|.macro LdRConst_neg_one,XREG; LdRConstH XREG,0xbff00000; .endmacro

/* -----------------------------------------------------------
 * constant loading                                          |
 * ----------------------------------------------------------*/

// Currently our constant loading is *slow* due to the design of our GC
// and also the layout of each constant array. I think we have a way to
// optimize away one memory move. LuaJIT's constant loading is just one
// single instruction since they only get one constant array and they don't
// need to worry about GC move the reference

|.macro LdReal,reg,index
|  mov T1,qword [PROTO]
|  movsd reg, qword [T1+index*8+PrototypeLayout::kRealTableOffset]
|.endmacro

|.macro LdRealV,reg,index
|  mov T1,qword [PROTO]
|  mov reg, qword [T1+index*8+PrototypeLayout::kRealTableOffset]
|.endmacro

|.macro LdReal2Int,reg,index,temp
|  mov temp,qword [PROTO]
|  cvtsd2si reg,qword [temp+index*8+PrototypeLayout::kRealTableOffset]
|.endmacro

|.macro StRealACC,reg
|  movsd qword [ACC],reg
|.endmacro

|.macro StReal,idx,reg
|  movsd qword [STK+idx*8], reg
|.endmacro

|.macro StRealFromInt,idx,reg
|  cvtsi2sd xmm0,reg
|  movsd qword [STK+idx*8], xmm0
|.endmacro

// --------------------------------------------
// load upvalue value into register
|.macro LdUV,reg,index
|  mov T1,qword [RUNTIME+RuntimeLayout::kCurClsOffset]
|  mov T2,qword [T1+ClosureLayout::kUpValueOffset]
|  mov reg, qword [T2+index*8]
|.endmacro

|.macro StUV,index,reg
|  mov T1,qword [RUNTIME+RuntimeLayout::kCurClsOffset]
|  mov T2,qword [T1+ClosureLayout::kUpValueOffset]
|  mov qword [T2+index*8], reg
|.endmacro

// ----------------------------------------------
// Heap value related stuff

// This byte offset in little endian for type pattern inside of
// heap object header
#define HOH_TYPE_OFFSET 7

// Check whether a Value is a HeapObject
|.macro CheckHeap,val,fail_label
|  mov T1,val
|  shr T1,48
|  cmp T1L, Value::FLAG_HEAP
|  jne >fail_label
|.endmacro

// Set a pointer into a register , this is really painful
|.macro StHeap,val

|.if 0
|  mov T1,Value::FLAG_HEAP
|  shl T1,48
|  or val,T1
|.else
|  or  val,qword [->ValueHeapMaskStore]
|.endif

|.endmacro

// Load a pointer from Value object , assume this object
// is a pointer type
|.macro LdPtrFromV,dest,val
|.if 1
|  mov dest,Value::FLAG_HEAP_UNMASK
|  shl dest,48
|  or  dest,val
|.else
|  mov dest,val
|  or  dest,qword [->ValueHeapLoadMask]
|.endif
|.endmacro

|.macro DerefPtrFromV,v
|  and v, qword [->ValueHeapLoadMask]
|.endmacro

// It is painful to load a string into its Value format
|.macro LdStrV,val,index
|  mov T1 , qword [PROTO]
|  mov T2 , qword [T1+PrototypeLayout::kStringTableOffset]
|  mov val, qword [T2+index*8]
|  StHeap val
|.endmacro

|.macro LdStr,val,index
|  mov T1 , qword [PROTO]
|  mov T2 , qword [T1+PrototypeLayout::kStringTableOffset]
|  mov val, qword [T2+index*8]
|.endmacro

// General macro to check a heap object is certain type
|.macro CheckHeapPtrT,val,pattern,fail_label
|  cmp byte [val-HOH_TYPE_OFFSET], pattern
|  jne >fail_label
|.endmacro

|.macro CheckHeapT,val,pattern,fail_label
|  and val,qword [->ValueHeapMaskLoad]
|  mov val, qword [val]
|  CheckHeapPtrT val,pattern,fail_label
|.endmacro

// -------------------------------------------------------------------------
// Object bit pattern

#define OBJECT_BIT_PATTERN TYPE_OBJECT

#define LIST_BIT_PATTERN TYPE_LIST

#define SSO_BIT_PATTERN TYPE_STRING

#define CLOSURE_BIT_PATTERN TYPE_CLOSURE

#define EXTENSION_BIT_PATTERN TYPE_EXTENSION

// -------------------------------------------------------------------------
// Check an *GCRef* is Object or not

|.macro CheckObj,val,fail_label
|  CheckHeapT val,OBJECT_BIT_PATTERN,fail_label
|.endmacro

|.macro CheckObjV,val,fail_label
|  CheckHeap val,fail_label
|  CheckObj val,fail_label
|.endmacro

// --------------------------------------------------------------------------
// Check an *GCRef* is List or not

|.macro CheckList,val,fail_label
|  CheckHeapT val,LIST_BIT_PATTERN,fail_label
|.endmacro

|.macro CheckListV,val,fail_label
|  CheckHeap val,fail_label
|  CheckObj val,fail_label
|.endmacro

// --------------------------------------------------------------------------
// Check a *GCRef* is SSO or not , not stored in Value

// reg : pointer of String
|.macro CheckSSO,reg,fail
|  mov reg, qword [reg]
|  CheckHeapPtrT reg,SSO_BIT_PATTERN,fail
// dereference *once* from String* --> SSO*
|  mov reg, qword [reg]
|.endmacro

|.macro CheckSSOV,reg,fail
|  CheckHeap reg,fail
|  CheckHeapT,reg,SSO_BIT_PATTERN,fail
// dereference *once* from String* --> SSO*
|  mov reg, qword [reg]
|.endmacro

#define INTERP_HELPER_LIST(__) \
  /* arithmetic */                           \
  __(INTERP_START,InterpStart)               \
  __(INTERP_FAIL ,InterpFail)                \
  __(INTERP_RETURN,InterpReturn)             \
  __(INTERP_ARITH_REALL,InterpArithRealL)    \
  __(INTERP_ARITH_REALR,InterpArithRealR)    \
  __(INTERP_ARITH_VV,InterpArithVV)          \
  __(INTERP_POW_SLOWVR,InterpPowSlowVR)      \
  __(INTERP_POW_SLOWRV,InterpPowSlowRV)      \
  __(INTERP_POW_SLOWVV,InterpPowSlowVV)      \
  __(DIV_BY_ZERO,DivByZero)                  \
  /* comparison */                           \
  __(INTERP_COMPARERV,InterpCompareRV)       \
  __(INTERP_COMPAREVR,InterpCompareVR)       \
  __(INTERP_COMPAREVV,InterpCompareVV)       \
  /* property get/set */                     \
  __(INTERP_PROPGET_NOTFOUND,InterpPropGetNotFound)      \
  __(INTERP_PROPGET_NOTOBJECT,InterpPropGetNotObject)    \
  __(INTERP_PROPGET,InterpPropGet)           \
  __(INTERP_IDXGETI,InterpIdxGetI)           \
  __(INTERP_IDXGET ,InterpIdxGet )           \
  /* ---- debug helper ---- */               \
  __(PRINT_OP,PrintOP)                       \
  __(PRINT2  ,Print2 )                       \
  __(PRINT64 ,Print64)                       \
  __(PRINTF  ,PrintF )

enum {
  INTERP_HELPER_DUMMY = SIZE_OF_BYTECODE,

#define __(A,B) A,
  INTERP_HELPER_LIST(__)
#undef __

  DASM_GROWABLE_PC_SIZE
};

#define INTERP_HELPER_START (INTERP_HELPER_DUMMY+1)
#define INTERP_HELPER_SIZE (DASM_GROWABLE_PC_SIZE-INTERP_HELPER_ROUTINE_ENUM-1)

const char* GetInterpHelperName( int idx ) {
  switch(idx) {
#define __(A,B) case A: return #B;
    INTERP_HELPER_LIST(__)
    default:
      lava_unreachF("unknown helper with index:%d",idx);
      return NULL;
#undef __ // __
  }
}

/* -----------------------------------------------------------
 * Macro Interfaces for Dynasm                               |
 * ----------------------------------------------------------*/
#define Dst (&(bctx->dasm_ctx))

/* -----------------------------------------------------------
 * Interpreter Prolog                                        |
 * ----------------------------------------------------------*/
void GenerateInterpMisc( BuildContext* bctx ) {
  /* -------------------------------------------
   * Constant value needed for the interpreter |
   * ------------------------------------------*/
  // Align with cache line ???
  |.data
  |->ValueHeapMaskStore:
  |.dword Value::TAG_HEAP_STORE_MASK_LOWER,Value::TAG_HEAP_STORE_MASK_HIGHER // 8 bytes

  |->ValueHeapMaskLoad:
  |.dword Value::TAG_HEAP_LOAD_MASK_LOWER,Value::TAG_HEAP_LOAD_MASK_HIGHER // 8 bytes

  |->FlagTrueConst:
  |.dword Value::FLAG_TRUE // 4 bytes

  |->FlagFalseConst:
  |.dword Value::FLAG_FALSE // 4 bytes

  |->RealZero:
  |.dword 0,0  // 8 btyes

  |.code

  /* -------------------------------------------
   * Start of the code                         |
   * ------------------------------------------*/

  |.macro interp_prolog
  |  sub   rsp, RESERVE_RSP             // make room on the stack

  |  mov qword SAVED_R12,r12            // runtime
  |  mov qword SAVED_R13,r13            // proto
  |  mov qword SAVED_R14,r14            // stack
  |  mov qword SAVED_R15,r15            // dispatch
  |  mov qword SAVED_RBP,rbp            // PC
  |  mov qword SAVED_RBX,rbx            // used by ARG2 , this may be changed in the future
  |.endmacro

  |.macro interp_epilog
  |  mov r12, qword SAVED_R12
  |  mov r13, qword SAVED_R13
  |  mov r14, qword SAVED_R14
  |  mov r15, qword SAVED_R15
  |  mov rbp, qword SAVED_RBP
  |  mov rbx, qword SAVED_RBX

  |  add rsp, RESERVE_RSP
  |.endmacro

  /* -------------------------------------------
   * Interpreter Prolog                        |
   * ------------------------------------------*/
  |=> INTERP_START:
  |->InterpStart:
  // save all callee saved register since we use them to keep tracking of
  // our most important data structure
  |  interp_prolog

  |  mov RUNTIME ,CARG1                 // runtime
  |  mov PROTO   ,CARG2                 // proto
  |  mov STK     ,CARG3                 // stack
  |  mov PC      ,CARG4                 // pc
  |  mov DISPATCH,CARG5                 // dispatch

  |  mov qword SAVED_PC,CARG4           // save the *start* of bc array
  // run
  |  Dispatch

  /* -------------------------------------------
   * Interpreter exit handler                  |
   * ------------------------------------------*/
  |=> INTERP_FAIL:
  |->InterpFail:
  |  xor eax,eax
  |  interp_epilog
  |  ret

  |=> INTERP_RETURN:
  |->InterpReturn:
  |  mov rax, qword [ACC]
  |  mov qword [RUNTIME+RuntimeLayout::kRetOffset],rax
  |  mov rax,1

  |  interp_epilog
  |  ret
}

/* ------------------------------------------
 * helper functions/routines generation     |
 * -----------------------------------------*/

// ----------------------------------------
// helper macros
// ----------------------------------------
|.macro ret2acc
|  mov T1,rax
|  shr T1,32
|  cmp T1,VALUE_FAIL
|  je ->InterpFail
|  mov qword [ACC], rax
|  Dispatch
|.endmacro

|.macro retbool
|  test eax,eax
|  je ->InterpFail
|  Dispatch
|.endmacro

// saving the current PC into the Runtime object, this is
// needed for GC to figure out the correct active register
// layout during the GC marking phase
|.macro savepc
|  mov qword [RUNTIME+RuntimeLayout::kCurPCOffset], PC
|.endmacro

void GenerateHelper( BuildContext* bctx ) {

  /* ----------------------------------------
   * InterpArithXXX                         |
   * ---------------------------------------*/
  |=> INTERP_ARITH_REALL:
  |->InterpArithRealL:
  |  savepc
  |  mov CARG1,RUNTIME
  |  LdRealV CARG2,ARG1F
  |  fcall InterpreterDoArithmetic
  |  ret2acc

  |=> INTERP_ARITH_REALR:
  |->InterpArithRealR:
  |  savepc
  |  mov CARG1,RUNTIME
  |  LdRealV CARG3,ARG2F
  |  fcall InterpreterDoArithmetic
  |  ret2acc

  |=> INTERP_ARITH_VV:
  |->InterpArithVV:
  |  savepc
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG1F*8]
  |  mov CARG3, qword [STK+ARG2F*8]
  |  fcall InterpreterDoArithmetic
  |  ret2acc

  |=> INTERP_POW_SLOWRV:
  |->InterpPowSlowRV:
  |  savepc
  |  mov CARG1, RUNTIME
  |  LdRealV CARG2,ARG2F
  |  mov CARG3,qword [STK+ARG3F*8]
  |  lea CARG4, [STK+ARG1F*8]
  |  fcall InterpreterPow
  |  ret2acc

  |=> INTERP_POW_SLOWVR:
  |->InterpPowSlowVR:
  |  savepc
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG2F*8]
  |  LdRealV CARG3,ARG3F
  |  lea CARG4, [STK+ARG1F*8]
  |  fcall InterpreterPow
  |  ret2acc

  |=> INTERP_POW_SLOWVV:
  |->InterpPowSlowVV:
  |  savepc
  |  instr_D
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG2F*8]
  |  mov CARG3, qword [STK+ARG3F*8]
  |  lea CARG4, [STK+ARG1F*8]
  |  fcall InterpreterPow
  |  ret2acc

  /* -------------------------------------------
   * Interp Arithmetic Exception               |
   * ------------------------------------------*/
  |=> DIV_BY_ZERO:
  |->DivByZero:
  |  mov CARG1,RUNTIME
  |  lea CARG2,[PC-4]
  |  fcall InterpreterDivByZero
  |  jmp ->InterpFail

  /* -------------------------------------------
   * Interp Comparison                         |
   * ------------------------------------------*/
  |=> INTERP_COMPARERV:
  |->InterpCompareRV:
  |  savepc
  |  mov CARG1,RUNTIME
  |  LdRealV CARG2,ARG2F
  |  mov CARG3, qword [STK+ARG2F*8]
  |  fcall InterpreterDoCompare
  |  ret2acc

  |=> INTERP_COMPAREVR:
  |->InterpCompareVR:
  |  savepc
  |  mov CARG1,RUNTIME
  |  mov CARG2,qword [STK+ARG1F*8]
  |  LdRealV CARG3,ARG2F
  |  fcall InterpreterDoCompare
  |  ret2acc

  |=> INTERP_COMPAREVV:
  |->InterpCompareVV:
  |  savepc
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG1F*8]
  |  mov CARG3, qword [STK+ARG2F*8]
  |  fcall InterpreterDoCompare
  |  ret2acc

  /* -------------------------------------------------
   * Property Get/Set                                |
   * ------------------------------------------------*/
  |=> INTERP_PROPGET:
  |->InterpPropGet:
  |  savepc
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG1F*8]
  |  LdStr CARG3, ARG2F
  |  fcall InterpreterDoPropGet
  |  ret2acc

  |=> INTERP_PROPGET_NOTFOUND:
  |->InterpPropGetNotFound:
  |  savepc
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG1F*8]
  |  LdStr CARG3,ARG1F
  |  fcall InterpreterPropGetNotFound
  |  jmp ->InterpFail

  |=> INTERP_PROPGET_NOTOBJECT:
  |->InterpPropGetNotObject:
  |  savepc
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG1F*8]
  |  LdStr CARG3, ARG2F
  |  fcall InterpreterPropGetNotObject
  |  jmp ->InterpFail

  |=> INTERP_IDXGETI:
  |->InterpIdxGetI:
  |  savepc
  |  mov CARG1, RUNTIME
  |  mov CARG2, qword [STK+ARG1F*8]
  |  mov CARG3L , ARG2
  |  fcall InterpreterDoIdxGetI
  |  retbool
}

void GenerateOneBytecode( BuildContext* bctx, Bytecode bc ) {
  switch(bc) {
    /** =====================================================
     *  Call handling                                       |
     *  ====================================================*/
    case BC_RETNULL:
      |=> bc:
      |  instr_X
      |  mov dword [STK+ACCFIDX],Value::FLAG_NULL
      |  jmp ->InterpReturn
      break;

    case BC_RET:
      |=> bc:
      |  instr_X
      |  jmp ->InterpReturn
      break;

    /** =====================================================
     *  Register Move                                       |
     *  ====================================================*/
    case BC_MOVE:
      |=> bc:
      |  instr_E
      |  mov ARG3F,qword [STK+ARG2F*8]
      |  mov qword [STK+ARG1F*8],ARG3F
      |  Dispatch
      break;

    /** =====================================================
     *  Constant Loading                                    |
     *  ====================================================*/
    case BC_LOAD0:
      |=> bc:
      |  instr_F
      |  xorpd xmm0,xmm0
      |  movsd qword[STK+ARG1F*8], xmm0
      |  Dispatch
      break;

    case BC_LOAD1:
      |=> bc:
      |  instr_F
      |  LdRConst_one xmm0
      |  movsd qword[STK+ARG1F*8], xmm0
      |  Dispatch
      break;

    case BC_LOADN1:
      |=> bc:
      |  instr_F
      |  LdRConst_neg_one xmm0
      |  movsd qword[STK+ARG1F*8], xmm0
      |  Dispatch
      break;

    case BC_LOADR:
      |=> bc:
      |  instr_E
      |  LdReal xmm0,ARG2F
      |  movsd qword [STK+ARG1F*8],xmm0
      |  Dispatch
      break;

    case BC_LOADNULL:
      |=> bc:
      |  instr_F
      |  mov dword [STK+ARG1F*8+4],Value::FLAG_NULL
      |  Dispatch
      break;

    case BC_LOADTRUE:
      |=> bc:
      |  instr_F
      |  mov dword [STK+ARG1F*8+4],Value::FLAG_TRUE
      |  Dispatch
      break;

    case BC_LOADFALSE:
      |=> bc:
      |  instr_F
      |  mov dword [STK+ARG1F*8+4],Value::FLAG_FALSE
      |  Dispatch
      break;

    case BC_LOADSTR:
      |=> bc:
      |  instr_E
      |  LdStrV LREG,ARG2F
      |  mov qword [STK+ARG1F*8],LREG
      |  Dispatch
      break;

    // -------------------------------------------------
    // Loading List/Object/Clousure
    //
    //
    // For these bytecodes, no optimization is performed but
    // directly yield back to C++ function to do the job. It
    // has no points to optimize these cases since they are
    // small amount of bytecodes and also complicated to write
    // in assembly without too much gain
    //
    //
    // To reduce ICache stress, the decode routine is *not*
    // placed inlined with each BC_XXX here but in the slow
    // path. This is purposely to make the main part of
    // interpreter to be small which helps about the icache
    // footprint of hot code
    // ------------------------------------------------*/
    case BC_LOADLIST0:
      |=> bc:
      |  instr_F
      |  savepc
      |  mov CARG1,RUNTIME
      |  lea CARG2,[STK+ARG1F*8]
      |  fcall InterpreterDoLoadList0
      |  retbool
      break;
    case BC_LOADLIST1:
      |=>bc:
      |  instr_E
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  fcall InterpreterDoLoadList1
      |  retbool
      break;
    case BC_LOADLIST2:
      |=>bc:
      |  instr_D
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  mov CARG4, qword [STK+ARG3F*8]
      |  fcall InterpreterDoLoadList2
      |  retbool
      break;
    case BC_NEWLIST:
      |=>bc:
      |  jmp ->InterpNewList
      |  instr_B
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3L, ARG2
      |  fcall InterpreterDoNewList
      |  retbool
      break;
    case BC_ADDLIST:
      |=>bc:
      |  instr_E
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  fcall InterpreterDoAddList
      |  retbool
      break;
    case BC_LOADOBJ0:
      |=>bc:
      |  instr_F
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  fcall InterpreterDoLoadObj0
      |  retbool
      break;
    case BC_LOADOBJ1:
      |=>bc:
      |  instr_D
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  mov CARG4, qword [STK+ARG3F*8]
      |  fcall InterpreterDoLoadObj1
      |  retbool
      break;
    case BC_NEWOBJ:
      |=>bc:
      |  instr_B
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3L, ARG2
      |  fcall InterpreterDoNewObj
      |  retbool
      break;
    case BC_ADDOBJ:
      |=>bc:
      |  instr_D
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  mov CARG4, qword [STK+ARG3F*8]
      |  fcall InterpreterDoAddObj
      |  retbool
      break;
    case BC_LOADCLS:
      |=>bc:
      |  instr_C
      |  savepc
      |  mov CARG1,RUNTIME
      |  mov CARG2, STK
      |  mov CARG3L, ARG2
      |  lea CARG4 , [STK+ARG1F*8]
      |  fcall InterpreterDoLoadCls
      |  retbool
      break;

    /** =====================================================
     *  Arith XV                                            |
     *  ====================================================*/
    |.macro arith_rv,BC,slow_path,instr
    |  instr_D
    |  mov RREG, qword [STK+ARG3F*8]

    // Use arg3 as temporary in favoer over T1/T2
    |.if CHECK_NUMBER_MEMORY
    |  mov T0L, dword[STK+ARG3F*8+4]
    |.else
    |  mov T0,RREG
    |  shr T0,32
    |.endif

    |  cmp T0L, Value::FLAG_REAL
    |  jnb ->slow_path

    |  LdReal xmm0,ARG2F
    |  movd xmm1, RREG
    |  instr xmm0,xmm1
    |  StReal ARG1F,xmm0
    |  Dispatch
    |.endmacro

    case BC_ADDRV:
      |=>bc:
      |  arith_rv BC_ADDRV,InterpArithRealL,addsd
      break;

    case BC_SUBRV:
      |=>bc:
      |  arith_rv BC_SUBRV,InterpArithRealL,subsd
      break;

    case BC_MULRV:
      |=>bc:
      |  arith_rv BC_MULRV,InterpArithRealL,mulsd
      break;

    case BC_DIVRV:
      |=>bc:
      |  arith_rv BC_DIVRV,InterpArithRealL,divsd
      break;

    /* =========================================================
     * Arith VX                                                |
     * ========================================================*/
    |.macro arith_vr,BC,slow_path,instr
    |  instr_D
    |  mov LREG,qword [STK+ARG2F*8]

    |.if CHECK_NUMBER_MEMORY
    |  mov T0L ,dword [STK+ARG2F*8+4]
    |.else
    |  mov T0,LREG
    |  shr T0,32
    |.endif

    |  cmp T0L,Value::FLAG_REAL
    |  jnb ->slow_path

    |  movd xmm0,LREG
    |  LdReal xmm1,ARG3F
    |  instr xmm0,xmm1
    |  StReal ARG1F,xmm0
    |  Dispatch
    |.endmacro


    case BC_ADDVR:
      |=> bc:
      |  arith_vr BC_ADDVR,InterpArithRealR,addsd
      break;

    case BC_SUBVR:
      |=> bc:
      |  arith_vr BC_SUBVR,InterpArithRealR,subsd
      break;

    case BC_MULVR:
      |=> bc:
      |  arith_vr BC_MULVR,InterpArithRealR,mulsd
      break;

    case BC_DIVVR:
      |=> bc:
      |  arith_vr BC_DIVVR,InterpArithRealR,divsd
      break;

    /* ========================================================
     * ArithVV
     *
     * The arithVV is also optimized for common path here.
     * We inline all numeric calculation cases, int/real.
     * Other cases will be pushed back to call C++ function
     * which may be extended to support meta function call
     *
     * ========================================================*/
    // perform VV calaculation based on instruction
    |.macro arith_vv,BC,instrR
    |=> BC:
    |  instr_D

    // check the lhs to be integer or not
    |  mov LREG,qword [STK+ARG2F*8]
    |  cmp LREGL,Value::FLAG_REAL
    |  jnb ->InterpArithVV

    | // real && xx
    |  mov RREG,qword [STK+ARG3F*8]
    |  cmp RREGL,Value::FLAG_REAL
    |  jnb ->InterpArithVV

    |  movsd xmm0, qword [STK+ARG2F*8]
    |  instrR xmm0, qword [STK+ARG3F*8]
    |  StReal ARG1F,xmm0
    |  Dispatch
    |.endmacro

    case BC_ADDVV:
      |  arith_vv BC_ADDVV,addsd
      break;
    case BC_SUBVV:
      |  arith_vv BC_SUBVV,subsd
      break;
    case BC_MULVV:
      |  arith_vv BC_MULVV,mulsd
      break;
    case BC_DIVVV:
      |  arith_vv BC_DIVVV,divsd
      break;

    /* ========================================================
     * MODXX
     *
     *   Similar implementation like Lua not Luajit. Return casted
     *   integer's mod value instead of fmod style value. BTW, fmod
     *   is really slow
     *
     * ========================================================*/


    case BC_MODVR:
      |=>bc:
      |  instr_D

      |  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      |  jnb ->InterpArithVV

      |  LdReal2Int ARG3,ARG3F,T0
      |  cvtsd2si eax ,qword [STK+ARG2F*8]  // ARG2F == rax

      |.if CHECK_DIV_BY_ZERO
      |  test ARG3,ARG3
      |  je ->DivByZero
      |.endif

      |  cdq
      |  idiv     ARG3
      |  StRealFromInt ARG1F,edx
      |  Dispatch
      break;

    case BC_MODRV:
      |=>bc:
      |  instr_D

      |  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
      |  jnb ->InterpArithVV

      |  LdReal2Int eax,ARG2F,T0  // ARG2F == rax
      |  cvtsd2si ARG3 ,qword [STK+ARG3F*8]

      |.if CHECK_DIV_BY_ZERO
      |  test ARG3,ARG3
      |  je ->DivByZero
      |.endif

      |  cdq
      |  idiv ARG3
      |  StRealFromInt ARG1F,edx
      |  Dispatch

      break;

    case BC_MODVV:
      |=>bc :
      |  instr_D
      |  cmp dword [STK+ARG2F*8+4] , Value::FLAG_REAL
      |  jnb ->InterpArithVV

      |  cmp dword [STK+ARG3F*8+4] , Value::FLAG_REAL
      |  jnb ->InterpArithVV

      |  cvtsd2si eax, qword [STK+ARG2F*8]  // ARG2F == rax
      |  cvtsd2si ARG3,qword [STK+ARG3F*8]

      |.if CHECK_DIV_BY_ZERO
      |  test ARG3,ARG3
      |  je ->DivByZero
      |.endif

      |  cdq
      |  idiv ARG3
      |  StRealFromInt ARG1F,edx
      |  Dispatch
      break;

    /* ==============================================================
     * POW part
     *
     * Currently we directly use std::pow/pow in libc for simplicity.
     * For numeric type we will directly call pow for other types
     * we will fallback to slow C++ function
     * =============================================================*/

    |.macro call_pow
    |  fcall pow
    |  movsd qword [STK+ARG1F*8], xmm0  // ARG1F is callee saved
    |.endmacro

    |.macro arith_pow,REGL,XREG,ARG,slow_pow
    |  mov REGL,dword [STK+ARG*8+4]
    |  cmp REGL,Value::FLAG_REAL
    |  jnb ->slow_pow
    |  movsd XREG,qword [STK+ARG*8]
    |  call_pow
    |  Dispatch
    |.endmacro

    case BC_POWRV:
      |=> bc:
      |  instr_D
      |  LdReal xmm0,ARG2F
      |  arith_pow RREGL,xmm1,ARG3F,InterpPowSlowRV
      break;

    case BC_POWVR:
      |=> bc:
      |  instr_D
      |  LdReal xmm1,ARG3F
      |  arith_pow LREGL,xmm0,ARG2F,InterpPowSlowVR
      break;

    case BC_POWVV:
      |=> bc:
      |  jmp ->InterpPowSlowVV
      break;


    /* ====================================================================
     * Comparison
     *
     * Inline numeric comparison and also do promotion inline
     * ===================================================================*/

    /* --------------------------------------------------------------------
     * Comparison XV                                                      |
     * -------------------------------------------------------------------*/
    |.macro comp_xv,BC,slow_path,false_jmp
    |  instr_D
    |  mov RREG, qword[STK+ARG3F*8]

    |.if CHECK_NUMBER_MEMORY
    |  mov T0L , dword[STK+ARG3F*8+4]
    |.else
    |  mov T0,RREG
    |  shr T0,32
    |.endif

    |  cmp T0L, Value::FLAG_REAL
    |  jnb ->slow_path
    |  LdReal xmm0, ARG2F
    |  movd xmm1, RREG
    |  ucomisd xmm0, xmm1
    // cmov instruction is slower here , doesn't worth it
    |  false_jmp >1
    |  mov dword[STK+ARG1F*8+4], Value::FLAG_TRUE
    |2:
    |  Dispatch
    |1:
    |  mov dword[STK+ARG1F*8+4], Value::FLAG_FALSE
    |  jmp <2
    |.endmacro

    case BC_LTRV:
      |=>bc:
      |  comp_xv BC_LTRV,InterpDoCompareRV,jae
      break;
    case BC_LERV:
      |=> bc:
      |  comp_xv BC_LERV,InterpDoCompareRV,ja
      break;
    case BC_GTRV:
      |=>bc:
      |  comp_xv BC_GTRV,InterpDoCompareRV,jbe
      break;
    case BC_GERV:
      |=> bc:
      |  comp_xv BC_GERV,InterpDoCompareRV,jb
      break;
    case BC_EQRV:
      |=> bc:
      |  comp_xv BC_EQRV,InterpDoCompareRV,jne
      break;
    case BC_NERV:
      |=> bc:
      |  comp_xv BC_NERV,InterpDoCompareRV,je
      break;

    /* --------------------------------------------------------------------
     * Comparison VX                                                      |
     * -------------------------------------------------------------------*/
    |.macro comp_vx,BC,slow_path,false_jmp
    |  instr_D

    |  mov LREG,qword [STK+ARG2F*8]

    |.if CHECK_NUMBER_MEMORY
    |  mov T0L, dword [STK+ARG2F*8+4]
    |.else
    |  mov T0, RREG
    |  shr T0, 32
    |.endif

    |  cmp T0L, Value::FLAG_REAL
    |  jnb ->slow_path

    |  LdReal xmm1,ARG3F
    |  movd xmm0, LREG
    |  ucomisd xmm0,xmm1
    |  false_jmp >1
    |  mov dword [STK+ARG1F*8+4], Value::FLAG_TRUE
    |2:
    |  Dispatch
    |1:
    |  mov dword [STK+ARG1F*8+4], Value::FLAG_FALSE
    |  jmp <2
    |.endmacro

    case BC_LTVR:
      |=>bc:
      |  comp_vx BC_LTVR,InterpDoCompareVR,jae
      break;
    case BC_LEVR:
      |=>bc:
      |  comp_vx BC_LEVR,InterpDoCompareVR,ja
      break;
    case BC_GTVR:
      |=>bc:
      |  comp_vx BC_GTVR,InterpDoCompareVR,jbe
      break;
    case BC_GEVR:
      |=>bc:
      |  comp_vx BC_GEVR,InterpDoCompareVR,jb
      break;
    case BC_EQVR:
      |=>bc:
      |  comp_vx BC_EQVR,InterpDoCompareVR,jne
      break;
    case BC_NEVR:
      |=>bc:
      |  comp_vx BC_NEVR,InterpDoCompareVR,je
      break;


    /* --------------------------------------------------------
     * comparison VV
     *
     * We do inline type promotion and comparison for all
     * numeric type
     * --------------------------------------------------------*/
    |.macro comp_vv,BC,false_jmp
    |  instr_D

    |  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
    |  jnb ->slow_path

    |  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
    |  jnb ->slow_path

    |  movsd xmm0, qword [STK+ARG2F*8]
    |  ucomisd xmm0, qword  [STK+ARG3F*8]
    |  false_jmp >1
    |  mov dword [STK+ARG1F*8+4], Value::FLAG_TRUE
    |2:
    |  Dispatch
    |1:
    |  mov dword [STK+ARG1F*8+4], Value::FLAG_FALSE
    |  jmp <2
    |.endmacro

    case BC_LTVV:
      |=>bc:
      |  comp_vv,BC_LTVV,jae
      break;
    case BC_LEVV:
      |=>bc:
      |  comp_vv,BC_LEVV,ja
      break;
    case BC_GTVV:
      |=>bc:
      |  comp_vv,BC_GTVV,jbe
      break;
    case BC_GEVV:
      |=>bc:
      |  comp_vv,BC_GEVV,jb
      break;
    case BC_EQVV:
      |=>bc:
      |  comp_vv,BC_EQVV,jne
      break;
    case BC_NEVV:
      |=>bc:
      |  comp_vv,BC_NEVV,je
      break;

    // For string equality comparison , we inline SSO comparison since
    // they are just checking the address are equal or not
    |.macro eq_sv,BC,SlowPath,instr,false_jmp
    |  instr_D
    |  LdStr LREG,ARG2F
    |  mov RREG,qword [STK+ARG3F*8]
    |  CheckSSO LREG,1
    |  CheckSSOV RREG,1

    |.if USE_CMOV_COMP
    |  mov ARG2, Value::FLAG_FALSE
    |  cmp LREG,RREG
    |  instr ARG2,dword [->FlagTrueConst]
    |  mov dword [STK+ARG1F*8+4],ARG2
    |.else
    |  cmp LREG,RREG
    |  false_jmp >8
    |  mov dword [STK+ARG1F*8+4],Value::FLAG_TRUE
    |  jmp >7
    |8:
    |  mov dword [STK+ARG1F*8+4],Value::FLAG_FALSE
    |.endif

    |7:
    |  Dispatch

    |1:
    |  jmp ->SlowPath
    |.endmacro

    |.macro eq_vs,BC,SlowPath,instr,false_jmp
    |  instr_D
    |  mov LREG, qword [STK+ARG2F*8]
    |  LdStr RREG,ARG3F
    |  CheckSSOV LREG,1
    |  CheckSSO  RREG,1

    |.if USE_CMOV_COMP
    |  mov ARG2, Value::FLAG_FALSE
    |  cmp LREG,RREG
    |  instr ARG2,dword [->FlagTrueConst]
    |  mov dword [STK+ARG1F*8+4],ARG2
    |.else
    |  cmp LREG,RREG
    |  false_jmp >8
    |  mov dword [STK+ARG1F*8+4],Value::FLAG_TRUE
    |  jmp >7
    |8:
    |  mov dword [STK+ARG1F*8+4],Value::FLAG_FALSE
    |.endif

    |7:
    |  Dispatch

    |1:
    |  jmp ->SlowPath
    |.endmacro

    case BC_EQSV:
      |=> bc:
      |  eq_sv BC_EQSV,InterpCompareSV,cmove,jne
      break;
    case BC_EQVS:
      |=> bc:
      |  eq_vs BC_EQVS,InterpCompareVS,cmove,jne
      break;
    case BC_NESV:
      |=>bc:
      |  eq_sv BC_NESV,InterpCompareSV,cmovne,je
      break;
    case BC_NEVS:
      |=>bc:
      |  eq_vs BC_NEVS,InterpCompareVS,cmovne,je
      break;

    /* -------------------------------------------------
     * Unary                                           |
     * ------------------------------------------------*/

    // inline integers and reals inlined to be processed
    // and other types are throwed away to the slower
    // functions to help since we may need to support meta
    // function in the future
    case BC_NEGATE:
      |=> bc:
      |  instr_E
      |  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      |  jnb >8

      |  movsd, xmm0, qword [STK+ARG2F*8]
      |  LdRConst_sign xmm1
      |  xorpd xmm0, xmm1
      |  movsd qword [STK+ARG1F*8], xmm0
      |  Dispatch

      |8:
      |  mov CARG1, RUNTIME
      |  mov CARG2, qword [STK+ARG2F*8]
      |  lea CARG3, [STK+ARG1F*8]
      |  fcall InterpreterDoNegate
      |  retbool
      break;

    case BC_NOT:
      |=> bc:
      |  instr_E
      |  mov ARG3, Value::FLAG_FALSE
      // check if the value is a heap object
      |  cmp word [STK+ARG2F*8+6], Value::FLAG_HEAP
      |  je >1
      |  cmp dword [STK+ARG2F*8+4], Value::FLAG_FALSECOND
      |  cmova ARG3, dword [->FlagTrueConst]
      |1:
      |  mov dword [STK+ARG1F*8+4], ARG3
      |  Dispatch
      break;

    // ------------------------------------------------
    // Branch                                         |
    // -----------------------------------------------*/

    // branch PC
    |.macro branch_to,where,TEMP
    |  mov TEMP,qword SAVED_PC
    |  lea PC,[TEMP+where*4]
    |.endmacro

    case BC_JMPT:
      |=>bc:
      |  instr_B
      |  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      |  je >2
      |  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      |  ja >1
      |2:
      |  branch_to ARG2F,ARG3F
      |1:  // fallthrough
      |  Dispatch
      break;

    case BC_JMPF:
      |=>bc:
      |  instr_B
      |  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      |  je >2
      |  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      |  jbe >2
      |  branch_to ARG2F,ARG3F
      |2: // fallthrough
      |  Dispatch
      break;

    case BC_AND:
      |=>bc:
      |  instr_B
      |  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      |  je >1
      |  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      |  jbe >1
      |  branch_to ARG2F,ARG3F
      |1: // fallthrough
      |  Dispatch
      break;

    case BC_OR:
      |=>bc:
      |  instr_B
      |  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      |  je >2
      |  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      |  ja >1
      |2:
      |  branch_to ARG2F,ARG3F
      |1: // fallthrough
      |  Dispatch
      break;

    case BC_JMP:
      |=>bc:
      |  instr_G
      |  branch_to ARG1F,ARG3F
      |  Dispatch
      break;

    // ----------------------------------------------------------
    // Property/Upvalue/Global
    // ---------------------------------------------------------*/

    // A better way to implement property get/set is via IC (inline cache)
    // but currently we don't have IC states at bytecode level and we will
    // add it guide the JIT compilation phase. For interpreter, we will use
    // something simpler but good to capture most of the cases. Since we force
    // our internal hash use SSO's default hash value to serve as hash value
    // of the key, so we will use a trick that is used in LuaJIT here. For
    // key that is SSO, we will retrieve its hash value out and directly
    // generate index to anchor its main position inside of the *chain* and
    // if we miss we will fallback to the slow path

    // LREG --> Object*
    // RREG --> SSO*
    |.macro find_sso_pos,output
    |  mov T2,LREG

    |  mov T2L, dword [T2+MapLayout::kCapacityOffset]

    |  mov T1L, dword [RREG+SSOLayout::kHashOffset]

    // T2L capacity , T1L size
    |  sub T2L,1

    // T1L -> index
    |  and T1L,T2L

    // index into the array
    |  lea T2L, [LREG+(MapLayout::kArrayOffset)]
    |  lea T1L, [T1L+T1L*2]
    |  lea T2L, [T2L+T1L*8]

    // save map's starting address
    |  lea T1 , [LREG+MapLayout::kArrayOffset]

    // 1. check if this entry is *deleted* or *used*
    |  mov LREGL, dword [T2L+MapEntryLayout::kFlagOffset]
    |  test LREGL,((1<<30))
    |  je >7  // not found main position is empty

    |1:
    // 2. check if it is deleted
    |  test LREGL,((1<<31))
    |  jne >6 // deleted slots

    // 3. check if the key is a SSO
    |  mov LREG, qword [T2L]
    |  CheckSSO LREG,6
    |  mov LREG, qword [LREG]
    |  cmp LREG, RREG
    |  jne >6 // string not identical

    // now we find the entry
    |  mov T2,qword [T2L+MapEntryLayout::kValueOffset]
    |  mov qword [STK+output*8], T2
    |  Dispatch

    // move to next iteration
    |6:
    |  mov LREGL, dword [T2L+MapEntryLayout::kFlagOffset]
    |  test LREGL,((1<<29))
    |  je >7
    |  and LREGL, ((bits::BitOn<std::uint32_t,0,29>::value))
    |  lea T2L  , [LREGL+LREGL*2]
    |  lea T2L  , [T1+T2L*8]
    |  mov LREGL, dword [T2L*8+MapEntryLayout::kFlagOffset]
    |  jmp <1

    |7:
    |  jmp ->InterpPropGetNotFound

    |.endmacro

    case BC_PROPGET:
      |=>bc:
      |  instr_B

      |.if 1
      |  cmp word [STK+ARG1F*8+6],Value::FLAG_HEAP
      |  jne >8
      |  mov LREG, qword [STK+ARG1F*8]
      |  CheckObj LREG,9
      |.else
      |  mov LREG, qword [STK+ARG1F*8]
      |  CheckObjV LREG,9
      |.endif

      |  LdStr RREG,ARG2F
      // assume RREG is an heap object since this should be guaranteed
      // by front-end
      |  DerefPtrFromV RREG
      |  CheckSSO RREG,8

      // find sso's position
      |  find_sso_pos ACCIDX

      |8: // should be done by slow path of InterpPorpGet
      |  jmp ->InterpPropGet

      |9: // failed at *object*
      |  jmp ->InterpPropGetNotObject
      break;

    case BC_PROPSET:
      // propset is directly yielded back to C++ functions
      |=>bc:
      |  instr_B
      |  savepc
      |  mov CARG1, RUNTIME
      |  mov CARG2, qword [ACC]
      |  mov CARG3, qword [STK+ARG1F*8]
      |  LdStr CARG4,ARG2F
      |  fcall InterpreterDoPropSet
      |  retbool
      break;

    case BC_IDXGET:
      |=>bc:
      |  instr_E
      |  savepc
      |  mov CARG1, RUNTIME
      |  mov CARG2, qword [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  fcall InterpreterDoIdxGet
      |  retbool
      break;
    case BC_IDXSET:
      |=>bc:
      |  instr_D
      |  savepc
      |  mov CARG1, RUNTIME
      |  mov CARG2, qword [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  mov CARG4, qword [STK+ARG3F*8]
      |  fcall InterpreterDoIdxSet
      |  retbool
      break;

    case BC_UVGET:
      |=>bc:
      |  instr_B
      |  LdUV LREG,ARG2F
      |  mov  qword [STK+ARG1F*8], LREG
      |  Dispatch
      break;

    case BC_UVSET:
      |=>bc:
      |  instr_C
      |  mov RREG, qword [STK+ARG2F*8]
      |  StUV ARG1F,RREG
      |  Dispatch
      break;

    case BC_GSET:
      |=>bc:
      |  instr_C
      |  savepc
      |  mov CARG1, RUNTIME
      |  LdStr CARG2, ARG1F
      |  mov CARG3, qword [STK+ARG2F*8]
      |  fcall InterpreterDoGSet
      |  retbool
      break;

    case BC_GGET:
      |=>bc:
      |  instr_B
      |  savepc
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  LdStr CARG3, ARG2F
      |  fcall InterpreterDoGGet
      |  retbool
      break;

    /* ========================================================
     * Loop instructions
     *
     * Loop is optimized for situation that condition/step and
     * induction variable are all *integer* value
     * =======================================================*/
    case BC_FSTART:
      |=>bc:
      |  instr_B
      // must be boolean flag here
      |  cmp dword [STK+ACCFIDX], Value::FLAG_FALSE
      |  je >1
      |2:
      |  Dispatch
      |1:
      |  branch_to ARG2F,ARG3F
      |  jmp <2
      break;

    case BC_FEND1:
      |=>bc:
      |  instr_E // actually TYPE_H instruction
      |  cmp dword [STK+ARG1F*8+4], Value::FLAG_REAL
      |  jnb ->InterpreterForEnd1

      |  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      |  jnb ->InterpreterForEnd1

      |  movsd xmm0, qword [STK+ARG1F*8]
      |  ucomisd xmm0, qword [STK+ARG2F*8]
      |  jae >8 // loop exit

      |  mov ARG1, dword [PC]
      |  branch_to ARG1F,ARG3F
      |7:
      |  Dispatch
      |8:
      |  // skip the 4th argument
      |  add PC,4
      |  jmp <8

      |6: // fallback for situation that is not integer
      |  mov CARG1, RUNTIME
      |  mov CARG2, qword [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  mov CARG4L, dword [PC]
      |  fcall InterpreterForEnd1
      // handle return value
      |  test eax,eax
      |  je ->InterpFail
      |  mov PC, qword [RUNTIME+RuntimeLayout::kCurPCOffset]
      |  Dispatch
      break;

    case BC_FEND2:
      |=>bc:
      |  instr_D
      |  cmp dword [STK+ARG1F*8+4], Value::FLAG_REAL
      |  jnb >6
      |  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      |  jnb >6
      |  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
      |  jnb >6

      |  movsd xmm0, qword [STK+ARG1F*8]
      |  addsd xmm0, qword [STK+ARG3F*8]
      |  ucomisd xmm0, qword [STK+ARG2F*8]
      |  movsd qword [STK+ARG1F*8], xmm0 // need to write back
      |  jae >8 // loop exit

      // fallthrough
      |  mov ARG1, dword [PC]
      |  branch_to ARG1F,ARG3F
      |7:
      |  Dispatch
      |8:
      |  add PC,4
      |  jmp <7

      |6:
      |  mov CARG1, RUNTIME
      |  lea CARG2, [STK+ARG1F*8]
      |  mov CARG3, qword [STK+ARG2F*8]
      |  mov CARG4, qword [STK+ARG3F*8]
      |  mov CARG5L, dword [PC]
      |  fcall InterpreterForEnd2
      |  test eax,eax
      |  je ->InterpFail
      |  mov PC, qword [RUNTIME+RuntimeLayout::kCurPCOffset]
      |  Dispatch
      break;

    case BC_FEVRSTART:
      |=>bc:
      |  instr_X
      |  Dispatch
      break;

    case BC_FEVREND:
      |=>bc:
      |  instr_G
      |  branch_to ARG1F,ARG3F
      |  Dispatch
      break;

    default:
      |=> bc:
      |  Break
      break;
  }
}

// Help Dasm to resolve external address via Index idx
int ResolveExternAddress( void** ctx , unsigned char* addr ,
                                       int idx,
                                       int type ) {
  (void)ctx;

  ExternSymbolTable* t = GetExternSymbolTable();
  ExternSymbolTable::iterator itr = t->find(extnames[idx]);

  lava_verify( itr != t->end() );

  void* ptr = itr->second;
  lava_verify(CheckAddress(reinterpret_cast<std::uintptr_t>(ptr)));

  int iptr = HorribleCast(ptr);
  lava_verify(reinterpret_cast<void*>(iptr) == ptr);

  if(type) {
    int end = HorribleCast(addr+4);

    // Check whether the address is overflowed or not. I think this is
    // not needed but just in cases we have a bug so we don't end up
    // calling into some wired places into our code
    std::int64_t ptr64 = static_cast<std::int64_t>(iptr);
    std::int64_t end64 = static_cast<std::int64_t>(end);

    lava_verify( (ptr64-end64) >= std::numeric_limits<int>::min() &&
                 (ptr64-end64) <= std::numeric_limits<int>::max() );

    return iptr - HorribleCast(addr+4);
  } else {
    return iptr;
  }
}

} // namespace

AssemblyInterpreter::AssemblyInterpreter():
  dispatch_interp_(),
  dispatch_record_(),
  dispatch_jit_   (),
  interp_helper_  (),
  interp_entry_   (),
  code_buffer_    (),
  code_size_      (),
  buffer_size_    ()
{}

AssemblyInterpreter::~AssemblyInterpreter() {
  if(interp_entry_) OS::FreeCodePage(code_buffer_,buffer_size_);
}

std::shared_ptr<AssemblyInterpreter> AssemblyInterpreter::Generate() {
  static std::shared_ptr<AssemblyInterpreter> interp;
  if(interp) return interp; // return interp if we already have a interpreter pointer

  // create a new interp object since this is our first time
  interp.reset( new AssemblyInterpreter() );

  // create a build context
  BuildContext bctx;

  // initialize dasm_State object
  dasm_init(&(bctx.dasm_ctx),2);

  // setup the freaking global
  void* glb_arr[GLBNAME__MAX];
  dasm_setupglobal(&(bctx.dasm_ctx),glb_arr,GLBNAME__MAX);

  // setup the dasm
  dasm_setup(&(bctx.dasm_ctx),actions);

  // initialize the tag value needed , at least for each BC we need one
  bctx.tag = DASM_GROWABLE_PC_SIZE;
  dasm_growpc(&(bctx.dasm_ctx), DASM_GROWABLE_PC_SIZE );

  // ----------------------------------------------------------
  // Order matters, it may change profile of our icache
  // ----------------------------------------------------------

  // build the helper
  GenerateHelper(&bctx);

  // build the prolog
  GenerateInterpMisc(&bctx);

  // generate all bytecode's routine
  for( int i = 0 ; i < SIZE_OF_BYTECODE ; ++i ) {
    GenerateOneBytecode(&bctx,static_cast<Bytecode>(i));
  }

  std::size_t code_size;

  // we should never fail at *linking* if our code is *correct*
  lava_verify(dasm_link(&(bctx.dasm_ctx),&code_size) ==0);

  // generate a buffer and set the proper protection field for that piece of
  // memory to make our code *work*
  std::size_t new_size;

  void* buffer = OS::CreateCodePage(code_size,&new_size);
  if(!buffer) {
    return std::shared_ptr<AssemblyInterpreter>();
  }

  // encode the assembly code into the buffer
  dasm_encode(&(bctx.dasm_ctx),buffer);

  // get all pc labels for entry of bytecode routine
  for( int i = 0 ; i < SIZE_OF_BYTECODE ; ++i ) {
    int off = dasm_getpclabel(&(bctx.dasm_ctx),i);
    interp->dispatch_interp_[i] =
      reinterpret_cast<void*>(static_cast<char*>(buffer) + off);
  }

  // get all pc labels for helper routines
  for( int i = INTERP_HELPER_START ; i < DASM_GROWABLE_PC_SIZE ; ++i ) {
    int off = dasm_getpclabel(&(bctx.dasm_ctx),i);
    interp->interp_helper_.push_back(
        reinterpret_cast<void*>(static_cast<char*>(buffer)+off));
  }

  // start of the code buffer
  interp->code_buffer_  = buffer;

  // get the *interpreter's* entry
  int off = dasm_getpclabel(&(bctx.dasm_ctx),INTERP_START);
  interp->interp_entry_ = reinterpret_cast<void*>(
      static_cast<char*>(buffer) + off);

  interp->buffer_size_  = new_size;
  interp->code_size_    = code_size;
  return interp;
}

Bytecode AssemblyInterpreter::CheckBytecodeRoutine( void* pc ) const {
  for( int i = 0 ; i < SIZE_OF_BYTECODE ; ++i ) {
    void* p = reinterpret_cast<void*>(pc);
    if(p == dispatch_interp_[i]) {
      return static_cast<Bytecode>(i);
    }
  }
  return SIZE_OF_BYTECODE;
}

int AssemblyInterpreter::CheckHelperRoutine( void* pc ) const {
  std::vector<void*>::const_iterator itr =
    std::find( interp_helper_.begin() , interp_helper_.end() , pc );
  if(itr != interp_helper_.end()) {
    return (static_cast<int>(std::distance(interp_helper_.begin(),itr))+INTERP_HELPER_START);
  } else {
    return -1;
  }
}

void AssemblyInterpreter::Dump( DumpWriter* writer ) const {
  ZydisDecoder decoder;
  ZydisDecoderInit( &decoder, ZYDIS_MACHINE_MODE_LONG_64,
                              ZYDIS_ADDRESS_WIDTH_64);

  ZydisFormatter formatter;
  ZydisFormatterInit(&formatter,ZYDIS_FORMATTER_STYLE_INTEL);

  std::uint64_t pc = reinterpret_cast<std::uint64_t>(code_buffer_);
  std::uint8_t* rp = static_cast<std::uint8_t*>(code_buffer_);
  std::size_t size = code_size_;

  writer->WriteL("CodeSize:%zu",code_size_);
  ZydisDecodedInstruction instr;
  while(ZYDIS_SUCCESS(
        ZydisDecoderDecodeBuffer(&decoder,rp,size,pc,&instr))) {

    char buffer[256];
    ZydisFormatterFormatInstruction(
        &formatter,&instr,buffer,sizeof(buffer));
    // check labels
    {
      Bytecode bc = CheckBytecodeRoutine(reinterpret_cast<void*>(pc));
      if(bc != SIZE_OF_BYTECODE) {
        writer->WriteL("Bytecode ===========> %s:",GetBytecodeName(bc));
      } else {
        int idx = CheckHelperRoutine(reinterpret_cast<void*>(pc));
        if(idx >= 0) {
          writer->WriteL("Helper ===========> %s:",GetInterpHelperName(idx));
        }
      }
    }
    writer->WriteL("%016" PRIX64 " (%d) %s",pc,instr.length,buffer);
    rp += instr.length;
    size -= instr.length;
    pc += instr.length;
  }
}

AssemblyInterpreter::Instance::Instance( const std::shared_ptr<AssemblyInterpreter>& interp ):
  dispatch_interp_(),
  dispatch_record_(),
  dispatch_jit_   (),
  interp_         (interp) {

  memcpy(dispatch_interp_,interp->dispatch_interp_,sizeof(dispatch_interp_));
  memcpy(dispatch_record_,interp->dispatch_record_,sizeof(dispatch_record_));
  memcpy(dispatch_jit_   ,interp->dispatch_jit_   ,sizeof(dispatch_jit_   ));
}

bool AssemblyInterpreter::Instance::Run( Context* context , const Handle<Script>& script ,
                                                            const Handle<Object>& globals,
                                                            std::string* error,
                                                            Value* rval ) {

  Runtime* rt = context->gc()->GetInterpreterRuntime(script.ref(), globals.ref(), error);
  // Entry of our assembly interpreter
  Main m = reinterpret_cast<Main>(interp_->interp_entry_);

  // Interpret the bytecode
  bool ret = m(rt,rt->cur_proto,reinterpret_cast<void*>(rt->stack),
                                const_cast<void*>(
                                  reinterpret_cast<const void*>((*(rt->cur_proto))->code_buffer())),
                                dispatch_interp_);
  // Check return
  if(ret) {
    *rval = rt->ret;
  }

  context->gc()->ReturnInterpreterRuntime(rt);
  return ret;
}

} // namespace interpreter
} // namespace lavascript
