/*
** This file has been pre-processed with DynASM.
** http://luajit.org/dynasm.html
** DynASM version 1.3.0, DynASM x64 version 1.3.0
** DO NOT EDIT! The original file is in "src/interpreter/bytecode-interpreter.dasc".
*/

#line 1 "src/interpreter/bytecode-interpreter.dasc"
#include "bytecode-interpreter.h"
#include "interpreter-frame.h"
#include "interpreter-runtime.h"

#include "src/context.h"
#include "src/trace.h"
#include "src/os.h"
#include "src/config.h"

#include <algorithm>
#include <map>
#include <cassert>
#include <climits>
#include <Zydis/Zydis.h>

// This the C symbol we use to resolve certain runtime function. Ideally these
// functions *should* be replaced with carefully tuned inline assembly but we
// could just call this out for current phase/stage. Later on to work at better
// version of these functions
extern "C" {
double pow(double,double);
} // extern "C"

namespace lavascript {
namespace interpreter{

inline void SetValueFlag( Value* v , std::uint32_t flag ) {
  v->raw_ = static_cast<std::uint64_t>(flag) << 32;
}

inline std::uint32_t GetValueFlag( const Value& v ) {
  return static_cast<std::uint32_t>(v.raw_ >>32);
}

namespace {

// Used in dynasm library
int ResolveExternAddress( void**,unsigned char*,int,int );

// Workaround for ODR
#include "dep/dynasm/dasm_proto.h"

#define DASM_EXTERN_FUNC(a,b,c,d) ResolveExternAddress((void**)a,b,c,d)
#include "dep/dynasm/dasm_x86.h"

// -------------------------------------------------------------
// BuildContext
//
// Build phase context, used to *generate* templated interpreter
// -------------------------------------------------------------
struct BuildContext {
  dasm_State* dasm_ctx;
  int tag;

  BuildContext():
    dasm_ctx(NULL),
    tag(0)
  {}

  ~BuildContext() {
    if(dasm_ctx) dasm_free(&dasm_ctx);
  }
};


// Shut the GCC's mouth fucked up
template< typename T >
int HorribleCast( T* ptr ) {
  std::uint64_t iptr = reinterpret_cast<std::uint64_t>(ptr);
  int ret = static_cast<int>(iptr);
  lava_verify(reinterpret_cast<T*>(ret) == ptr);
  return ret;
}


// ------------------------------------------------------------------
// Prototype for the main interpreter function
//
// @ARG1: runtime
// @ARG2: Prototype** of the function
// @ARG3: start of the stack
// @ARG4: start of the code buffer for the *Prototype*
// @ARG5: start of the dispatch table
typedef bool (*Main)(Runtime*,Prototype**,void*,void*,void*);

// ------------------------------------------------------------------
//
// Helper function/macros to register its literal name into a global
// table to help resolve the function's address during assembly link
// phase
//
// ------------------------------------------------------------------
typedef std::map<std::string,void*> ExternSymbolTable;

ExternSymbolTable* GetExternSymbolTable() {
  static ExternSymbolTable kTable;
  return &kTable;
}

// Macro to register a external function's symbol name into global table
#define INTERPRETER_REGISTER_EXTERN_SYMBOL(XX)                               \
  struct XX##_Registry {                                                     \
    XX##_Registry() {                                                        \
      ExternSymbolTable* table = GetExternSymbolTable();                     \
      table->insert(std::make_pair(#XX,reinterpret_cast<void*>(&XX)));       \
    }                                                                        \
  };                                                                         \
  static XX##_Registry k##XX##_Registry;


// ------------------------------------------------------------------
// Builtin libc function exposure section
// ------------------------------------------------------------------
INTERPRETER_REGISTER_EXTERN_SYMBOL(pow)


// -------------------------------------------------------------------
// Helper to set Value object to indicate special meaning
// -------------------------------------------------------------------
#define VALUE_FAIL Value::FLAG_1

/* --------------------------------------------------------------------------
 *
 * Interpreter C++ Part Function Implementation
 *
 * -------------------------------------------------------------------------*/
inline std::uint32_t CurrentBytecode( Runtime* sandbox ) {
  /**
   * We do have instruction occupy 2 slots , *BUT* we don't need to consider
   * this because that byte is added on demand.
   *
   * When we reach to C++ function, our PC should still points to the added
   * byte for that instruction if our previous instruction is a 2 byte.
   *
   * So we only need to substract one of the *current* PC
   */
  return sandbox->cur_pc[-1];
}

inline Bytecode CurrentOpcode( Runtime* sandbox ) {
  std::uint32_t pbc = CurrentBytecode(sandbox);
  return static_cast<Bytecode>( pbc & 0xff );
}

// --------------------------------------------------------------------------
// Arithmetic Helper
// --------------------------------------------------------------------------
bool InterpreterDoArithmetic( Runtime* sandbox , Value left ,
                                                 Value right,
                                                 Value* output ) {
  (void)sandbox;
  (void)left;
  (void)right;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoArithmetic)

bool InterpreterPow         ( Runtime* sandbox , Value left,
                                                 Value right ,
                                                 Value* output ) {
  (void)sandbox;
  (void)left;
  (void)right;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPow)

void InterpreterDivByZero    ( Runtime* sandbox , std::uint32_t* pc ) {
  (void)sandbox;
  (void)pc;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDivByZero)


// ---------------------------------------------------------------------------
// Comparison Helper
// ---------------------------------------------------------------------------
bool  InterpreterDoCompare  ( Runtime* sandbox , Value left ,
                                                 Value right,
                                                 Value* output ) {
  (void)sandbox;
  (void)left;
  (void)right;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoCompare)

// This function shuold *never* trigger GC
bool InterpreterCompareHH  ( Runtime* sandbox , HeapObject* left,
                                                HeapObject* right,
                                                Value* output ) {
  (void)sandbox;
  (void)left;
  (void)right;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterCompareHH)

// ----------------------------------------------------------------------------
// Unary Helper
// ----------------------------------------------------------------------------
bool InterpreterDoNegate   ( Runtime* sandbox , Value  operand ,
                                                Value* result ) {
  (void)sandbox;
  (void)operand;
  (void)result;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoNegate)

// ----------------------------------------------------------------------------
// Literal Loader Helper
// ----------------------------------------------------------------------------
bool InterpreterDoLoadList0  ( Runtime* sandbox , Value* output ) {
  (void)sandbox;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadList0)

bool InterpreterDoLoadList1  ( Runtime* sandbox , Value* output ,
                                                  Value e1 ) {
  (void)sandbox;
  (void)output;
  (void)e1;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadList1)

bool InterpreterDoLoadList2  ( Runtime* sandbox , Value* output ,
                                                  Value e1,
                                                  Value e2 ) {
  (void)sandbox;
  (void)output;
  (void)e1;
  (void)e2;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadList2)

bool InterpreterDoNewList   ( Runtime* sandbox , Value* output ,
                                                  std::uint32_t narg ) {
  (void)sandbox;
  (void)output;
  (void)narg;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoNewList)

bool InterpreterDoAddList   ( Runtime* sandbox , Value* output ,
                                                 Value  val ) {
  (void)sandbox;
  (void)output;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoAddList)

bool InterpreterDoLoadObj0   ( Runtime* sandbox , Value* output ) {
  (void)sandbox;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadObj0)

bool InterpreterDoLoadObj1   ( Runtime* sandbox , Value* output ,
                                                  Value  key,
                                                  Value  val ) {
  (void)sandbox;
  (void)output;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadObj1)

bool InterpreterDoNewObj    ( Runtime* sandbox , Value* output ,
                                                 std::uint32_t narg ) {
  (void)sandbox;
  (void)output;
  (void)narg;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoNewObj)

bool InterpreterDoAddObj    ( Runtime* sandbox , Value* output ,
                                                 Value  key,
                                                 Value  val ) {
  (void)sandbox;
  (void)output;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoAddObj)

bool InterpreterDoLoadCls   ( Runtime* sandbox , Value* start_of_stack ,
                                                 std::uint32_t prototype_id ,
                                                 Value* dest ) {
  (void)sandbox;
  (void)start_of_stack;
  (void)prototype_id;
  (void)dest;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterDoLoadCls)

// ----------------------------------------------------------------------------
// Property Get/Set
// ----------------------------------------------------------------------------
bool  InterpreterPropGet   ( Runtime* sandbox , Value obj , String** key ,
                                                            Value* output ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPropGet)

void InterpreterPropGetNotFound( Runtime* sandbox , Value obj , String** key ) {
  (void)sandbox;
  (void)obj;
  (void)key;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPropGetNotFound)

void InterpreterPropNeedObject ( Runtime* sandbox, Value obj ) {
  (void)sandbox;
  (void)obj;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPropNeedObject)

void InterpreterIdxOutOfBound  ( Runtime* sandbox , Value obj , std::uint32_t size ) {
  (void)sandbox;
  (void)obj;
  (void)size;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterIdxOutOfBound)

bool InterpreterPropSet      ( Runtime* sandbox , Value obj , String** key ,
                                                              Value val ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterPropSet)

bool InterpreterIdxGet      ( Runtime* sandbox , Value obj , Value key ,
                                                             Value* output ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterIdxGet)

bool  InterpreterIdxGetI     ( Runtime* sandbox , Value obj , std::uint8_t idx ,
                                                              Value* output ) {
  (void)sandbox;
  (void)obj;
  (void)idx;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterIdxGetI)

bool InterpreterIdxSet      ( Runtime* sandbox , Value obj , Value key ,
                                                             Value val ) {
  (void)sandbox;
  (void)obj;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterIdxSet)

bool InterpreterIdxSetI    ( Runtime* sandbox , Value obj  , std::uint8_t idx ,
                                                             Value val ) {
  (void)sandbox;
  (void)obj;
  (void)idx;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterIdxSetI)

bool InterpreterGGet       ( Runtime* sandbox , Value* output , String** key ) {
  (void)sandbox;
  (void)key;
  (void)output;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterGGet)

bool InterpreterGSet       ( Runtime* sandbox , String** key , Value value ) {
  (void)sandbox;
  (void)key;
  (void)value;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterGSet)


// ----------------------------------------------------------------------------
// Loop
// ----------------------------------------------------------------------------
bool InterpreterForEnd1     ( Runtime* sandbox , Value lhs , Value rhs ,
                                                             std::uint32_t offset ) {
  (void)sandbox;
  (void)lhs;
  (void)rhs;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterForEnd1)

bool InterpreterForEnd2     ( Runtime* sandbox , Value lhs , Value rhs ,
                                                             Value cond ,
                                                             std::uint32_t offset ) {
  (void)sandbox;
  (void)lhs;
  (void)rhs;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterForEnd2)

bool InterpreterFEStart     ( Runtime* sandbox , Value* expr , std::uint32_t offset ) {
  (void)sandbox;
  (void)expr;
  (void)offset;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterFEStart)

bool InterpreterFEEnd       ( Runtime* sandbox , Value expr , std::uint32_t offset ) {
  (void)sandbox;
  (void)expr;
  (void)offset;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterFEEnd)

bool InterpreterIDref       ( Runtime* sandbox , Value expr , Value* key , Value* val ) {
  (void)sandbox;
  (void)expr;
  (void)key;
  (void)val;
  return false;
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(InterpreterIDref)


/* ---------------------------------------------------------------------
 *
 * Implementation of AssemblyIntepreter
 *
 * --------------------------------------------------------------------*/
//|.arch x64
#if DASM_VERSION != 10300
#error "Version mismatch between DynASM and included encoding engine"
#endif
#line 466 "src/interpreter/bytecode-interpreter.dasc"
//|.actionlist actions
static const unsigned char actions[6405] = {
  254,1,248,10,237,237,255,248,11,237,237,255,248,12,237,255,248,13,237,255,
  248,14,0,0,0,0,0,0,0,0,255,254,0,249,248,15,255,72,131,252,236,72,76,137,
  100,36,40,76,137,108,36,32,76,137,116,36,24,76,137,124,36,16,72,137,108,36,
  8,72,137,92,36,48,255,73,137,252,252,73,137,252,245,73,137,214,72,137,205,
  77,137,199,255,72,137,12,36,255,139,69,0,72,15,182,200,72,131,197,4,193,232,
  8,65,252,255,36,207,255,249,248,16,49,192,76,139,100,36,40,76,139,108,36,
  32,76,139,116,36,24,76,139,124,36,16,72,139,108,36,8,72,139,92,36,48,72,131,
  196,72,195,255,249,248,17,73,139,134,252,248,7,0,0,73,137,132,253,36,233,
  72,199,192,1,0,0,0,255,249,248,18,73,137,172,253,36,233,76,137,231,77,139,
  93,0,73,139,180,253,195,233,73,139,20,206,73,141,12,222,255,232,251,1,0,255,
  72,184,237,237,252,255,208,255,133,192,15,132,244,16,139,69,0,72,15,182,200,
  72,131,197,4,193,232,8,65,252,255,36,207,255,249,248,19,73,137,172,253,36,
  233,76,137,231,73,139,52,198,77,139,93,0,73,139,148,253,203,233,73,141,12,
  222,255,249,248,20,73,137,172,253,36,233,76,137,231,73,139,52,222,73,139,
  20,198,73,141,12,206,255,249,248,21,73,137,172,253,36,233,76,137,231,77,139,
  93,0,73,139,180,253,195,233,73,139,20,206,73,141,12,222,255,232,251,1,1,255,
  249,248,22,73,137,172,253,36,233,76,137,231,73,139,52,198,77,139,93,0,73,
  139,148,253,203,233,73,141,12,222,255,249,248,23,73,137,172,253,36,233,72,
  15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,76,137,231,73,139,52,198,
  73,139,20,206,73,141,12,222,255,249,248,24,76,137,231,72,141,117,252,252,
  255,232,251,1,2,255,252,233,244,16,255,249,248,25,73,137,172,253,36,233,76,
  137,231,77,139,93,0,73,139,180,253,195,233,73,139,20,198,73,141,12,222,255,
  232,251,1,3,255,249,248,26,73,137,172,253,36,233,76,137,231,73,139,52,198,
  77,139,93,0,73,139,148,253,203,233,73,141,12,222,255,249,248,27,73,137,172,
  253,36,233,76,137,231,73,139,52,198,73,139,20,206,73,141,12,222,255,249,248,
  28,73,137,172,253,36,233,76,137,231,73,139,52,198,77,139,93,0,77,139,147,
  233,73,139,20,202,73,141,12,222,255,232,251,1,4,255,249,248,29,73,137,172,
  253,36,233,76,137,231,73,139,52,198,77,139,93,0,77,139,147,233,73,139,20,
  202,255,232,251,1,5,255,249,248,30,73,137,172,253,36,233,76,137,231,73,139,
  52,198,255,232,251,1,6,255,249,248,31,73,137,172,253,36,233,76,137,231,73,
  139,52,198,137,202,73,141,12,222,255,232,251,1,7,255,249,248,32,73,137,172,
  253,36,233,76,137,231,73,139,52,222,137,194,73,139,12,206,255,232,251,1,8,
  255,249,248,33,73,137,172,253,36,233,76,137,231,73,139,52,198,137,202,255,
  232,251,1,9,255,249,248,34,73,137,172,253,36,233,76,137,231,73,139,52,222,
  137,194,255,249,65,199,134,252,252,7,0,0,237,252,233,244,17,255,249,252,233,
  244,17,255,249,15,182,216,193,232,8,73,139,12,198,73,137,12,222,139,69,0,
  72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,15,182,216,
  102,15,87,192,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,
  193,232,8,65,252,255,36,207,255,249,15,182,216,73,187,237,237,102,73,15,110,
  195,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,
  65,252,255,36,207,255,249,15,182,216,193,232,8,77,139,93,0,252,242,65,15,
  16,132,253,195,233,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,
  4,193,232,8,65,252,255,36,207,255,249,15,182,216,65,199,68,222,4,237,139,
  69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,15,182,
  216,193,232,8,77,139,93,0,77,139,147,233,73,139,52,194,72,11,53,244,10,73,
  137,52,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,
  255,249,15,182,216,73,137,172,253,36,233,76,137,231,73,141,52,222,255,232,
  251,1,10,255,249,15,182,216,193,232,8,73,137,172,253,36,233,76,137,231,73,
  141,52,222,73,139,20,198,255,232,251,1,11,255,249,72,15,182,216,193,232,8,
  15,182,204,37,252,255,0,0,0,73,137,172,253,36,233,76,137,231,73,141,52,222,
  73,139,20,198,73,139,12,206,255,232,251,1,12,255,249,252,233,244,35,72,15,
  182,216,193,232,8,73,137,172,253,36,233,76,137,231,73,141,52,222,137,194,
  255,232,251,1,13,255,232,251,1,14,255,232,251,1,15,255,232,251,1,16,255,249,
  72,15,182,216,193,232,8,73,137,172,253,36,233,76,137,231,73,141,52,222,137,
  194,255,232,251,1,17,255,232,251,1,18,255,249,72,15,183,216,193,232,16,73,
  137,172,253,36,233,76,137,231,76,137,252,246,137,194,73,141,12,222,255,232,
  251,1,19,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,73,139,
  20,206,72,137,215,72,193,252,239,32,129,252,255,239,15,131,244,18,77,139,
  93,0,252,242,65,15,16,132,253,195,233,102,72,15,110,202,252,242,15,88,193,
  252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,
  255,36,207,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,73,
  139,20,206,72,137,215,72,193,252,239,32,129,252,255,239,15,131,244,18,77,
  139,93,0,252,242,65,15,16,132,253,195,233,102,72,15,110,202,252,242,15,92,
  193,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,
  65,252,255,36,207,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,
  0,0,73,139,20,206,72,137,215,72,193,252,239,32,129,252,255,239,15,131,244,
  18,77,139,93,0,252,242,65,15,16,132,253,195,233,102,72,15,110,202,252,242,
  15,89,193,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,193,
  232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,15,182,204,37,252,
  255,0,0,0,73,139,20,206,72,137,215,72,193,252,239,32,129,252,255,239,15,131,
  244,18,77,139,93,0,252,242,65,15,16,132,253,195,233,102,72,15,110,202,252,
  242,15,94,193,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,
  193,232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,15,182,204,37,
  252,255,0,0,0,73,139,52,198,72,137,252,247,72,193,252,239,32,129,252,255,
  239,15,131,244,19,102,72,15,110,198,77,139,93,0,252,242,65,15,16,140,253,
  203,233,252,242,15,88,193,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,
  131,197,4,193,232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,15,
  182,204,37,252,255,0,0,0,73,139,52,198,72,137,252,247,72,193,252,239,32,129,
  252,255,239,15,131,244,19,102,72,15,110,198,77,139,93,0,252,242,65,15,16,
  140,253,203,233,252,242,15,92,193,252,242,65,15,17,4,222,139,69,0,72,15,182,
  200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,
  8,15,182,204,37,252,255,0,0,0,73,139,52,198,72,137,252,247,72,193,252,239,
  32,129,252,255,239,15,131,244,19,102,72,15,110,198,77,139,93,0,252,242,65,
  15,16,140,253,203,233,252,242,15,89,193,252,242,65,15,17,4,222,139,69,0,72,
  15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,72,15,182,216,
  193,232,8,15,182,204,37,252,255,0,0,0,73,139,52,198,72,137,252,247,72,193,
  252,239,32,129,252,255,239,15,131,244,19,102,72,15,110,198,77,139,93,0,252,
  242,65,15,16,140,253,203,233,252,242,15,94,193,252,242,65,15,17,4,222,139,
  69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,72,15,
  182,216,193,232,8,15,182,204,37,252,255,0,0,0,73,139,52,198,129,252,254,239,
  15,131,244,20,73,139,20,206,129,252,250,239,15,131,244,20,252,242,65,15,16,
  4,198,252,242,65,15,88,4,206,252,242,65,15,17,4,222,139,69,0,72,15,182,200,
  72,131,197,4,193,232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,
  15,182,204,37,252,255,0,0,0,73,139,52,198,129,252,254,239,15,131,244,20,73,
  139,20,206,129,252,250,239,15,131,244,20,252,242,65,15,16,4,198,252,242,65,
  15,92,4,206,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,193,
  232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,15,182,204,37,252,
  255,0,0,0,73,139,52,198,129,252,254,239,15,131,244,20,73,139,20,206,129,252,
  250,239,15,131,244,20,252,242,65,15,16,4,198,252,242,65,15,89,4,206,252,242,
  65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,
  207,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,73,139,52,
  198,129,252,254,239,15,131,244,20,73,139,20,206,129,252,250,239,15,131,244,
  20,252,242,65,15,16,4,198,252,242,65,15,94,4,206,252,242,65,15,17,4,222,139,
  69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,72,15,
  182,216,193,232,8,15,182,204,37,252,255,0,0,0,255,65,129,124,253,198,4,239,
  15,131,244,20,255,73,139,125,0,252,242,15,45,140,253,207,233,252,242,65,15,
  45,4,198,255,133,201,15,132,244,24,255,153,252,247,252,249,252,242,15,42,
  194,252,242,65,15,17,4,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,
  65,252,255,36,207,255,65,129,124,253,206,4,239,15,131,244,20,255,73,139,125,
  0,252,242,15,45,132,253,199,233,252,242,65,15,45,12,206,255,249,72,15,182,
  216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,198,4,239,15,131,
  244,20,255,252,242,65,15,45,4,198,252,242,65,15,45,12,206,255,249,72,15,182,
  216,193,232,8,15,182,204,37,252,255,0,0,0,77,139,93,0,252,242,65,15,16,132,
  253,195,233,65,139,84,206,4,129,252,250,239,15,131,244,21,252,242,65,15,16,
  12,206,255,232,251,1,20,255,249,72,15,182,216,193,232,8,15,182,204,37,252,
  255,0,0,0,77,139,93,0,252,242,65,15,16,140,253,203,233,65,139,116,198,4,129,
  252,254,239,15,131,244,22,252,242,65,15,16,4,198,255,249,252,233,244,23,255,
  249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,206,
  4,239,15,131,244,25,77,139,93,0,252,242,65,15,16,132,253,195,233,102,65,15,
  46,4,206,15,131,244,247,65,199,68,222,4,237,248,2,139,69,0,72,15,182,200,
  72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,199,68,222,4,237,252,233,
  244,2,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,
  124,253,206,4,239,15,131,244,25,77,139,93,0,252,242,65,15,16,132,253,195,
  233,102,65,15,46,4,206,15,135,244,247,65,199,68,222,4,237,248,2,139,69,0,
  72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,199,68,222,
  4,237,252,233,244,2,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,
  0,0,0,65,129,124,253,206,4,239,15,131,244,25,77,139,93,0,252,242,65,15,16,
  132,253,195,233,102,65,15,46,4,206,15,134,244,247,65,199,68,222,4,237,248,
  2,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,
  199,68,222,4,237,252,233,244,2,255,249,72,15,182,216,193,232,8,15,182,204,
  37,252,255,0,0,0,65,129,124,253,206,4,239,15,131,244,25,77,139,93,0,252,242,
  65,15,16,132,253,195,233,102,65,15,46,4,206,15,130,244,247,65,199,68,222,
  4,237,248,2,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,
  248,1,65,199,68,222,4,237,252,233,244,2,255,249,72,15,182,216,193,232,8,15,
  182,204,37,252,255,0,0,0,65,129,124,253,206,4,239,15,131,244,25,77,139,93,
  0,252,242,65,15,16,132,253,195,233,102,65,15,46,4,206,15,133,244,247,65,199,
  68,222,4,237,248,2,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,
  36,207,248,1,65,199,68,222,4,237,252,233,244,2,255,249,72,15,182,216,193,
  232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,206,4,239,15,131,244,25,
  77,139,93,0,252,242,65,15,16,132,253,195,233,102,65,15,46,4,206,15,132,244,
  247,65,199,68,222,4,237,248,2,139,69,0,72,15,182,200,72,131,197,4,193,232,
  8,65,252,255,36,207,248,1,65,199,68,222,4,237,252,233,244,2,255,249,72,15,
  182,216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,198,4,239,15,
  131,244,26,77,139,93,0,252,242,65,15,16,140,253,203,233,252,242,65,15,16,
  4,198,102,15,46,193,15,131,244,247,65,199,68,222,4,237,248,2,139,69,0,72,
  15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,199,68,222,4,
  237,252,233,244,2,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,
  0,0,65,129,124,253,198,4,239,15,131,244,26,77,139,93,0,252,242,65,15,16,140,
  253,203,233,252,242,65,15,16,4,198,102,15,46,193,15,135,244,247,65,199,68,
  222,4,237,248,2,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,
  36,207,248,1,65,199,68,222,4,237,252,233,244,2,255,249,72,15,182,216,193,
  232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,198,4,239,15,131,244,26,
  77,139,93,0,252,242,65,15,16,140,253,203,233,252,242,65,15,16,4,198,102,15,
  46,193,15,134,244,247,65,199,68,222,4,237,248,2,139,69,0,72,15,182,200,72,
  131,197,4,193,232,8,65,252,255,36,207,248,1,65,199,68,222,4,237,252,233,244,
  2,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,124,
  253,198,4,239,15,131,244,26,77,139,93,0,252,242,65,15,16,140,253,203,233,
  252,242,65,15,16,4,198,102,15,46,193,15,130,244,247,65,199,68,222,4,237,248,
  2,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,
  199,68,222,4,237,252,233,244,2,255,249,72,15,182,216,193,232,8,15,182,204,
  37,252,255,0,0,0,65,129,124,253,198,4,239,15,131,244,26,77,139,93,0,252,242,
  65,15,16,140,253,203,233,252,242,65,15,16,4,198,102,15,46,193,15,133,244,
  247,65,199,68,222,4,237,248,2,139,69,0,72,15,182,200,72,131,197,4,193,232,
  8,65,252,255,36,207,248,1,65,199,68,222,4,237,252,233,244,2,255,249,72,15,
  182,216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,198,4,239,15,
  131,244,26,77,139,93,0,252,242,65,15,16,140,253,203,233,252,242,65,15,16,
  4,198,102,15,46,193,15,132,244,247,65,199,68,222,4,237,248,2,139,69,0,72,
  15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,199,68,222,4,
  237,252,233,244,2,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,
  0,0,65,129,124,253,198,4,239,15,131,244,27,65,129,124,253,206,4,239,15,131,
  244,27,252,242,65,15,16,4,198,102,65,15,46,4,206,15,131,244,247,65,199,68,
  222,4,237,248,2,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,
  36,207,248,1,65,199,68,222,4,237,252,233,244,2,255,249,72,15,182,216,193,
  232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,198,4,239,15,131,244,27,
  65,129,124,253,206,4,239,15,131,244,27,252,242,65,15,16,4,198,102,65,15,46,
  4,206,15,135,244,247,65,199,68,222,4,237,248,2,139,69,0,72,15,182,200,72,
  131,197,4,193,232,8,65,252,255,36,207,248,1,65,199,68,222,4,237,252,233,244,
  2,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,124,
  253,198,4,239,15,131,244,27,65,129,124,253,206,4,239,15,131,244,27,252,242,
  65,15,16,4,198,102,65,15,46,4,206,15,134,244,247,65,199,68,222,4,237,248,
  2,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,
  199,68,222,4,237,252,233,244,2,255,249,72,15,182,216,193,232,8,15,182,204,
  37,252,255,0,0,0,65,129,124,253,198,4,239,15,131,244,27,65,129,124,253,206,
  4,239,15,131,244,27,252,242,65,15,16,4,198,102,65,15,46,4,206,15,130,244,
  247,65,199,68,222,4,237,248,2,139,69,0,72,15,182,200,72,131,197,4,193,232,
  8,65,252,255,36,207,248,1,65,199,68,222,4,237,252,233,244,2,255,249,72,15,
  182,216,193,232,8,15,182,204,37,252,255,0,0,0,65,129,124,253,198,4,239,15,
  131,244,249,65,129,124,253,206,4,239,15,131,244,249,252,242,65,15,16,4,198,
  102,65,15,46,4,206,15,133,244,247,65,199,68,222,4,237,248,2,139,69,0,72,15,
  182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,1,65,199,68,222,4,237,
  252,233,244,2,248,3,73,139,52,198,73,139,20,206,72,137,252,247,73,137,211,
  72,193,252,238,48,72,193,252,234,48,72,57,214,15,133,244,250,129,252,254,
  239,15,132,244,251,255,129,252,250,239,15,132,244,251,65,199,68,222,4,237,
  252,233,244,2,248,4,65,199,68,222,4,237,252,233,244,2,248,5,72,35,61,244,
  11,72,139,63,128,191,233,235,15,133,244,253,72,139,63,76,35,29,244,11,77,
  139,27,65,128,187,233,235,255,15,133,244,253,77,139,27,76,57,223,15,133,244,
  252,65,199,68,222,4,237,248,6,65,199,68,222,4,237,252,233,244,2,248,7,76,
  137,231,72,137,252,254,76,137,218,73,141,76,222,4,255,232,251,1,21,255,249,
  72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,77,139,93,0,77,139,147,
  233,73,139,52,194,73,139,20,206,72,139,54,128,190,233,235,15,133,244,247,
  72,139,54,73,137,211,73,193,252,235,48,65,129,252,251,239,15,133,244,247,
  72,35,21,244,11,72,139,18,128,186,233,235,15,133,244,247,72,139,18,72,57,
  214,15,133,244,254,65,199,68,222,4,237,252,233,244,253,248,8,255,65,199,68,
  222,4,237,248,7,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,
  36,207,248,1,252,233,244,36,255,249,72,15,182,216,193,232,8,15,182,204,37,
  252,255,0,0,0,73,139,52,198,77,139,93,0,77,139,147,233,73,139,20,202,73,137,
  252,243,73,193,252,235,48,65,129,252,251,239,15,133,244,247,72,35,53,244,
  11,72,139,54,128,190,233,235,15,133,244,247,72,139,54,72,139,18,128,186,233,
  235,15,133,244,247,72,139,18,72,57,214,15,133,244,254,65,199,68,222,4,237,
  252,233,244,253,248,8,255,65,199,68,222,4,237,248,7,139,69,0,72,15,182,200,
  72,131,197,4,193,232,8,65,252,255,36,207,248,1,252,233,244,37,255,249,72,
  15,182,216,193,232,8,15,182,204,37,252,255,0,0,0,77,139,93,0,77,139,147,233,
  73,139,52,194,73,139,20,206,72,139,54,128,190,233,235,15,133,244,247,72,139,
  54,73,137,211,73,193,252,235,48,65,129,252,251,239,15,133,244,247,72,35,21,
  244,11,72,139,18,128,186,233,235,15,133,244,247,72,139,18,72,57,214,15,132,
  244,254,65,199,68,222,4,237,252,233,244,253,248,8,255,249,72,15,182,216,193,
  232,8,15,182,204,37,252,255,0,0,0,73,139,52,198,77,139,93,0,77,139,147,233,
  73,139,20,202,73,137,252,243,73,193,252,235,48,65,129,252,251,239,15,133,
  244,247,72,35,53,244,11,72,139,54,128,190,233,235,15,133,244,247,72,139,54,
  72,139,18,128,186,233,235,15,133,244,247,72,139,18,72,57,214,15,132,244,254,
  65,199,68,222,4,237,252,233,244,253,248,8,255,249,15,182,216,193,232,8,65,
  129,124,253,198,4,239,15,131,244,254,255,252,242,65,15,16,4,198,73,187,237,
  237,102,73,15,110,203,102,15,87,193,252,242,65,15,17,4,222,139,69,0,72,15,
  182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,248,8,76,137,231,73,
  139,52,198,73,141,20,222,255,232,251,1,22,255,249,15,182,216,193,232,8,185,
  237,255,102,65,129,124,253,198,6,238,15,132,244,247,65,129,124,253,198,4,
  239,15,71,13,244,12,248,1,65,137,76,222,4,139,69,0,72,15,182,200,72,131,197,
  4,193,232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,102,65,129,
  124,253,222,6,238,15,132,244,248,65,129,124,253,222,4,239,15,135,244,247,
  248,2,72,139,12,36,72,141,44,129,248,1,139,69,0,72,15,182,200,72,131,197,
  4,193,232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,102,65,129,
  124,253,222,6,238,15,132,244,248,65,129,124,253,222,4,239,15,134,244,248,
  72,139,12,36,72,141,44,129,248,2,139,69,0,72,15,182,200,72,131,197,4,193,
  232,8,65,252,255,36,207,255,249,72,15,182,216,193,232,8,102,65,129,124,253,
  222,6,238,15,132,244,247,65,129,124,253,222,4,239,15,134,244,247,72,139,12,
  36,72,141,44,129,248,1,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,
  255,36,207,255,249,72,15,183,216,72,139,12,36,72,141,44,153,139,69,0,72,15,
  182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,72,15,182,216,193,
  232,8,255,102,65,129,124,253,222,6,238,15,133,244,254,73,139,52,222,72,35,
  53,244,11,72,139,54,128,190,233,235,15,133,244,255,255,77,139,93,0,77,139,
  147,233,73,139,20,194,255,72,35,21,244,38,72,139,18,128,186,233,235,15,133,
  244,254,72,139,18,255,73,137,252,242,69,139,146,233,68,139,154,233,65,131,
  252,234,1,69,33,211,68,141,150,233,71,141,28,91,71,141,20,218,76,141,158,
  233,65,139,178,233,252,247,198,237,15,132,244,253,248,1,252,247,198,237,15,
  133,244,252,73,139,50,72,139,54,128,190,233,235,15,133,244,252,72,139,54,
  72,139,54,72,57,214,15,133,244,252,77,139,146,233,77,137,150,233,255,139,
  69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,6,65,139,
  178,233,252,247,198,237,15,132,244,253,129,230,239,68,141,20,118,71,141,20,
  211,66,139,52,213,237,252,233,244,1,248,7,252,233,244,29,255,248,8,252,233,
  244,28,255,248,9,252,233,244,30,255,249,72,15,182,216,193,232,8,73,137,172,
  253,36,233,76,137,231,73,139,182,252,248,7,0,0,73,139,20,222,77,139,93,0,
  77,139,147,233,73,139,12,194,255,232,251,1,23,255,249,72,15,182,216,193,232,
  8,15,182,204,37,252,255,0,0,0,102,65,129,124,253,206,4,238,15,131,244,247,
  252,242,65,15,45,12,206,133,201,15,136,244,34,255,102,65,129,124,253,198,
  6,238,15,133,244,30,73,139,52,198,72,35,53,244,11,72,139,54,128,190,233,235,
  15,133,244,31,59,142,233,15,131,244,34,72,139,150,233,72,139,2,72,139,132,
  253,200,233,73,137,4,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,
  252,255,36,207,255,248,1,76,137,231,73,139,52,198,73,139,20,206,73,141,12,
  222,255,232,251,1,24,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,
  0,0,0,102,65,129,124,253,198,6,238,15,133,244,30,73,139,52,198,72,35,53,244,
  11,72,139,54,128,190,233,235,15,133,244,31,59,142,233,15,131,244,34,72,139,
  150,233,72,139,2,72,139,132,253,200,233,73,137,4,222,139,69,0,72,15,182,200,
  72,131,197,4,193,232,8,65,252,255,36,207,255,102,65,129,124,253,198,4,238,
  15,131,244,247,255,133,192,15,132,244,33,255,102,65,129,124,253,222,6,238,
  15,133,244,30,73,139,52,222,72,35,53,244,11,72,139,54,128,190,233,235,15,
  133,244,32,59,134,233,15,131,244,33,72,139,150,233,72,139,26,73,139,52,206,
  72,137,180,253,195,233,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,
  255,36,207,255,248,1,73,137,172,253,36,233,76,137,231,73,139,52,222,73,139,
  20,198,73,139,12,206,255,232,251,1,25,255,249,72,15,182,216,193,232,8,15,
  182,204,37,252,255,0,0,0,102,65,129,124,253,222,6,238,15,133,244,30,73,139,
  52,222,72,35,53,244,11,72,139,54,128,190,233,235,15,133,244,32,59,134,233,
  15,131,244,33,72,139,150,233,72,139,26,73,139,52,206,72,137,180,253,195,233,
  139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,255,249,72,
  15,182,216,193,232,8,77,139,156,253,36,233,77,139,147,233,73,139,52,194,73,
  137,52,222,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,
  255,249,72,15,183,216,193,232,16,73,139,20,198,77,139,156,253,36,233,77,139,
  147,233,73,137,20,218,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,
  255,36,207,255,249,72,15,183,216,193,232,16,73,137,172,253,36,233,76,137,
  231,77,139,93,0,77,139,147,233,73,139,52,218,73,139,20,198,255,232,251,1,
  26,255,249,72,15,182,216,193,232,8,73,137,172,253,36,233,76,137,231,73,141,
  52,222,77,139,93,0,77,139,147,233,73,139,20,194,255,232,251,1,27,255,65,129,
  190,253,252,252,7,0,0,239,15,132,244,247,248,2,139,69,0,72,15,182,200,72,
  131,197,4,193,232,8,65,252,255,36,207,248,1,72,139,12,36,72,141,44,129,252,
  233,244,2,255,249,15,182,216,193,232,8,65,129,124,253,222,4,239,15,131,244,
  39,255,65,129,124,253,198,4,239,15,131,244,39,255,252,242,65,15,16,4,222,
  102,65,15,46,4,198,15,131,244,254,255,139,93,0,72,139,12,36,72,141,44,153,
  248,7,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,252,255,36,207,248,
  8,72,131,197,4,252,233,244,7,255,248,6,73,137,172,253,36,233,76,137,231,73,
  139,52,222,73,139,20,198,139,77,0,255,232,251,1,28,255,133,192,15,132,244,
  16,73,139,172,253,36,233,139,69,0,72,15,182,200,72,131,197,4,193,232,8,65,
  252,255,36,207,255,249,72,15,182,216,193,232,8,15,182,204,37,252,255,0,0,
  0,65,129,124,253,222,4,239,15,131,244,252,65,129,124,253,198,4,239,15,131,
  244,252,65,129,124,253,206,4,239,15,131,244,252,255,252,242,65,15,16,4,222,
  252,242,65,15,88,4,206,102,65,15,46,4,198,252,242,65,15,17,4,222,15,131,244,
  254,255,248,6,73,137,172,253,36,233,76,137,231,73,141,52,222,73,139,20,198,
  73,139,12,206,68,139,69,0,255,232,251,1,29,255,249,139,69,0,72,15,182,200,
  72,131,197,4,193,232,8,65,252,255,36,207,255,232,251,1,30,255,232,251,1,31,
  255,73,137,172,253,36,233,76,137,231,73,139,52,222,73,141,20,198,73,141,12,
  206,255,232,251,1,32,255,249,205,3,255
};

#line 467 "src/interpreter/bytecode-interpreter.dasc"
//|.globals GLBNAME_
enum {
  GLBNAME_ValueHeapMaskStore,
  GLBNAME_ValueHeapMaskLoad,
  GLBNAME_FlagTrueConst,
  GLBNAME_FlagFalseConst,
  GLBNAME_RealZero,
  GLBNAME_InterpStart,
  GLBNAME_InterpFail,
  GLBNAME_InterpReturn,
  GLBNAME_InterpArithRealL,
  GLBNAME_InterpArithRealR,
  GLBNAME_InterpArithVV,
  GLBNAME_InterpPowSlowRV,
  GLBNAME_InterpPowSlowVR,
  GLBNAME_InterpPowSlowVV,
  GLBNAME_DivByZero,
  GLBNAME_InterpCompareRV,
  GLBNAME_InterpCompareVR,
  GLBNAME_InterpCompareVV,
  GLBNAME_InterpPropGet,
  GLBNAME_InterpPropGetNotFound,
  GLBNAME_InterpPropNeedObject,
  GLBNAME_InterpIdxGetI,
  GLBNAME_InterpIdxSetI,
  GLBNAME_InterpIdxOutOfBoundSet,
  GLBNAME_InterpIdxOutOfBoundGet,
  GLBNAME_InterpNewList,
  GLBNAME_InterpCompareSV,
  GLBNAME_InterpCompareVS,
  GLBNAME_ValueHeapLoadMask,
  GLBNAME_InterpreterForEnd1,
  GLBNAME__MAX
};
#line 468 "src/interpreter/bytecode-interpreter.dasc"
//|.globalnames glbnames
static const char *const glbnames[] = {
  "ValueHeapMaskStore",
  "ValueHeapMaskLoad",
  "FlagTrueConst",
  "FlagFalseConst",
  "RealZero",
  "InterpStart",
  "InterpFail",
  "InterpReturn",
  "InterpArithRealL",
  "InterpArithRealR",
  "InterpArithVV",
  "InterpPowSlowRV",
  "InterpPowSlowVR",
  "InterpPowSlowVV",
  "DivByZero",
  "InterpCompareRV",
  "InterpCompareVR",
  "InterpCompareVV",
  "InterpPropGet",
  "InterpPropGetNotFound",
  "InterpPropNeedObject",
  "InterpIdxGetI",
  "InterpIdxSetI",
  "InterpIdxOutOfBoundSet",
  "InterpIdxOutOfBoundGet",
  "InterpNewList",
  "InterpCompareSV",
  "InterpCompareVS",
  "ValueHeapLoadMask",
  "InterpreterForEnd1",
  (const char *)0
};
#line 469 "src/interpreter/bytecode-interpreter.dasc"
//|.externnames extnames
static const char *const extnames[] = {
  "InterpreterDoArithmetic",
  "InterpreterPow",
  "InterpreterDivByZero",
  "InterpreterDoCompare",
  "InterpreterPropGet",
  "InterpreterPropGetNotFound",
  "InterpreterPropNeedObject",
  "InterpreterIdxGetI",
  "InterpreterIdxSetI",
  "InterpreterIdxOutOfBound",
  "InterpreterDoLoadList0",
  "InterpreterDoLoadList1",
  "InterpreterDoLoadList2",
  "InterpreterDoNewList",
  "InterpreterDoAddList",
  "InterpreterDoLoadObj0",
  "InterpreterDoLoadObj1",
  "InterpreterDoNewObj",
  "InterpreterDoAddObj",
  "InterpreterDoLoadCls",
  "pow",
  "InterpreterCompareHH",
  "InterpreterDoNegate",
  "InterpreterPropSet",
  "InterpreterIdxGet",
  "InterpreterIdxSet",
  "InterpreterGSet",
  "InterpreterGGet",
  "InterpreterForEnd1",
  "InterpreterForEnd2",
  "InterpreterFEStart",
  "InterpreterFEEnd",
  "InterpreterIDref",
  (const char *)0
};
#line 470 "src/interpreter/bytecode-interpreter.dasc"
//|.section code,data
#define DASM_SECTION_CODE	0
#define DASM_SECTION_DATA	1
#define DASM_MAXSECTION		2
#line 471 "src/interpreter/bytecode-interpreter.dasc"

/* -------------------------------------------------------------------
 * Preprocessor option for dynasm
 * ------------------------------------------------------------------*/
//|.define CHECK_DIV_BY_ZERO
//|.define CHECK_NUMBER_MEMORY,0
//|.define TRACE_OP,0
//|.define USE_CMOV_COMP,0
//|.define USE_CMOV_NEG

/* -------------------------------------------------------------------
 * 64 bits call
 *
 * Since 64 bits call cannot accept a imm value due to it is too long,
 * we need to generate different *types* of call instruction based on
 * the callsite
 * -------------------------------------------------------------------*/
inline bool CheckAddress( std::uintptr_t addr ) {
  static const std::uintptr_t k2G = 0x80000000;
  if(addr > 0 && addr < k2G)
    return true;
  else
    return false;
}

//|.macro fcall,FUNC
//|| if(CheckAddress(reinterpret_cast<std::uintptr_t>(FUNC))) {
//|    call extern FUNC
//|| } else {
//||   lava_warn("%s","Function FUNC address is not in 0-2GB");
//|.if 0
// I don't know whether this is faster than use rax , need profile. I see
// this one is used in MoarVM. It uses memory address to work araoud the
// address space problem. But I am kind of unsure about it since it maybe
// because MoarVM already allocate rax for other things
//|9:
//|.dword (std::uint32_t)((std::uintptr_t)(FUNC)),(std::uint32_t)((std::uintptr_t)((FUNC)>>32))
//|    call qword[<9]
//|.else
//|    mov64 rax, reinterpret_cast<std::uintptr_t>(FUNC)
//|    call rax
//|.endif
//|| }
//|.endmacro

/* ---------------------------------------------------------------
 * summary of register usage                                     |
 * --------------------------------------------------------------*/
// Runtime pointer
//|.define RUNTIME,               r12   // callee saved

// Current prototype's GCRef pointer
//|.define PROTO,                 r13   // callee saved

// Top stack's pointer
//|.define STK,                   r14   // callee saved
//|.define ACCIDX,                2040
//|.define ACCFIDX,               2044
//|.define ACCFHIDX,              2046  // for heap flag
//|.define ACC,                   STK+ACCIDX

// Dispatch table pointer
//|.define DISPATCH,              r15  // callee saved

// Bytecode array
//|.define PC,                    rbp  // callee saved

// Hold the decoded unit
//|.define INSTR,                 eax
//|.define INSTR_OP,              al
//|.define INSTR_A8L,             al
//|.define INSTR_A8H,             ah
//|.define INSTR_A16,             ax

// Frame -------------------------------------------------------
// We store the frame sizeof(IFrame) above STK pointer
static_assert( sizeof(IFrame) == 16 );
//|.define CFRAME,                STK-16
//|.define FRAMELEN,              16

// Instruction's argument
//|.define ARG1_8,                bl
//|.define ARG1_16,               bx
//|.define ARG1,                  ebx  // must *not* be 64 bits due to we use ah and it MUST be callee saved
//|.define ARG1F,                 rbx

// Used to help decode function's call argument
//|.define FARG,                  ebx  // aliased with ARG1
//|.define FARG16,                bx
//|.define FARG8L,                bl
//|.define FARG8H,                bh

//|.define ARG2_8,                al
//|.define ARG2_16,               ax
//|.define ARG2,                  eax
//|.define ARG2F,                 rax

//|.define ARG3_8,                cl
//|.define ARG3_16,               cx
//|.define ARG3,                  ecx
//|.define ARG3F,                 rcx

// temporarily alias OP to be ARG3 because during the
// decoding time , we don't need to hold anything there
//|.define OP,                    rcx

// temporary register are r10 and r11
//|.define LREG,                  rsi
//|.define LREGL,                 esi
//|.define LREGLL,                 si
//|.define RREG,                  rdx
//|.define RREGL,                 edx
//|.define RREGLL,                 dx

// absolute safe temporary variables
//
//
// In most places , prefer T0 as temporary register if ARGX
// is not free since it doesn't require REX encoding. But it
// alias with CARG1 , use with cautious
//|.define T0,                    rdi
//|.define T0L,                   edi
//|.define T0L16,                 di

//|.define T1,                    r11
//|.define T1L,                   r11d
//|.define T1L16,                 r11w

//|.define T2,                    r10
//|.define T2L,                   r10d
//|.define T2L16,                 r10w

// registers for normal C function calling ABI
//|.define CARG1,                 rdi
//|.define CARG2,                 rsi    // LREG
//|.define CARG3,                 rdx    // RREG
//|.define CARG4,                 rcx
//|.define CARG5,                 r8
//|.define CARG6,                 r9

//|.define CARG1L,                edi
//|.define CARG2L,                esi
//|.define CARG3L,                edx
//|.define CARG4L,                ecx
//|.define CARG5L,                r8d
//|.define CARG6L,                r9d

//|.define CARG1LL,               dil
//|.define CARG2LL,               sil
//|.define CARG3LL,               dl
//|.define CARG4LL,               cl
//|.define CARG5LL,               r8b
//|.define CARG6LL,               r9b

// saved callee registers plus some other important stuff
// 72 = 64 + (8 padding for function call)
//|.define RESERVE_RSP,           72
//|.define SAVED_RBX,             [rsp+48]
//|.define SAVED_R12,             [rsp+40]
//|.define SAVED_R13,             [rsp+32]
//|.define SAVED_R14,             [rsp+24]
//|.define SAVED_R15,             [rsp+16]
//|.define SAVED_RBP,             [rsp+8]

//|.define SAVED_PPC,             rsp
//|.define SAVED_PC ,             [rsp]

// Used to save certain registers while we call cross the function
// boundary. Like we may call into ToBoolean function to get value
// of certain register's Boolean value and we may need to save register
// like rax which is part of our argument/operand of isntructions
//|.define SAVED_SLOT1,           [rsp+56]
//|.define SAVED_SLOT2,           [rsp+64]

/* ---------------------------------------------------------------
 * debug helper                                                  |
 * --------------------------------------------------------------*/
//|.macro Break
//|  int 3
//|.endmacro

void PrintOP( int op ) {
  lava_error("OP:%s",GetBytecodeName(static_cast<Bytecode>(op)));
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(PrintOP)

void Print2( int a , int b ) {
  lava_error("L:%d,R:%d",a,b);
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(Print2)

void PrintF( double v ) {
  lava_error("Value:%f",v);
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(PrintF)

void Print64( std::uint64_t a , std::uint64_t b ) {
  lava_error("%" LAVA_FMTU64 ":%" LAVA_FMTU64,a,b);
}
INTERPRETER_REGISTER_EXTERN_SYMBOL(Print64)

/* ---------------------------------------------------------------
 * dispatch table                                                |
 * --------------------------------------------------------------*/
//|.macro Dispatch
//|.if TRACE_OP
//|  mov INSTR,dword [PC]
//|  movzx OP,INSTR_OP
//|  mov CARG1,OP
//|  fcall PrintOP
//|.endif
//|  mov INSTR,dword [PC]  // 1 uops
//|  movzx OP,INSTR_OP     // 1 uops
//|  add PC,4              // 1 uops
//|  shr INSTR,8           // 1 uops
//|  jmp aword [DISPATCH+OP*8]
//|.endmacro

/* ---------------------------------------------------------------
 * decode each instruction's argument/operand                    |
 * --------------------------------------------------------------*/

//|.macro instr_B
// cannot use ARG1F due to INSTR_A8 uses ah
//|  movzx ARG1F,INSTR_A8L
//|  shr INSTR,8
//|.endmacro

//|.macro instr_C
//|  movzx ARG1F,INSTR_A16
//|  shr INSTR,16
//|.endmacro

//|.macro instr_D
//|  movzx ARG1F,INSTR_A8L
//|  shr INSTR,8
// do not change ARG3 --> ARG3F even if it is better, due to the fact
// we cannot use ax register when rex prefix is used in instruction.
//|  movzx ARG3,INSTR_A8H
//|  and ARG2,0xff
//|.endmacro

//|.macro instr_E
//|  movzx ARG1,INSTR_A8L
//|  shr INSTR,8
//|.endmacro

//|.macro instr_F
//|  movzx ARG1,INSTR_A8L
//|.endmacro

//|.macro instr_G
//|  movzx ARG1F,INSTR_A16
//|.endmacro

//|.macro instr_X
//|.endmacro

//|.macro instr_N
//|  instr_D
//|.endmacro

/* -----------------------------------------------------------
 * Special Constant for Real                                 |
 * ----------------------------------------------------------*/
//|.macro rconstH,XREG,HIGH
//|  mov64 T1,(static_cast<std::uint64_t>(HIGH)<<32)
//|  movd XREG,T1
//|.endmacro

//|.macro rconstL,XREG,LOW
//|  mov64 T1,(static_cast<std::uint64_t>(LOW))
//|  movd XREG,T1
//|.endmacro

//|.macro rconst,XREG,X64V
//|  mov64 T1,X64V
//|  movd  XREG,T1
//|.endmacro

// Used to negate the double precision number's sign bit
//|.macro rconst_sign,XREG; rconstH XREG,0x80000000; .endmacro
//|.macro rconst_one ,XREG; rconstH XREG,0x3ff00000; .endmacro
//|.macro rconst_neg_one,XREG; rconstH XREG,0xbff00000; .endmacro

/* -----------------------------------------------------------
 * constant loading                                          |
 * ----------------------------------------------------------*/

// Currently our constant loading is *slow* due to the design of our GC
// and also the layout of each constant array. I think we have a way to
// optimize away one memory move. LuaJIT's constant loading is just one
// single instruction since they only get one constant array and they don't
// need to worry about GC move the reference

//|.macro LdReal,reg,index
//|  mov T1,qword [PROTO]
//|  movsd reg, qword [T1+index*8+PrototypeLayout::kRealTableOffset]
//|.endmacro

//|.macro LdRealV,reg,index
//|  mov T1,qword [PROTO]
//|  mov reg, qword [T1+index*8+PrototypeLayout::kRealTableOffset]
//|.endmacro

//|.macro LdReal2Int,reg,index,temp
//|  mov temp,qword [PROTO]
//|  cvtsd2si reg,qword [temp+index*8+PrototypeLayout::kRealTableOffset]
//|.endmacro

//|.macro StRealACC,reg
//|  movsd qword [ACC],reg
//|.endmacro

//|.macro StReal,idx,reg
//|  movsd qword [STK+idx*8], reg
//|.endmacro

//|.macro StRealFromInt,idx,reg
//|  cvtsi2sd xmm0,reg
//|  movsd qword [STK+idx*8], xmm0
//|.endmacro

// --------------------------------------------
// load upvalue value into register
//|.macro LdUV,reg,index
//|  mov T1,qword [RUNTIME+RuntimeLayout::kCurClsOffset]
//|  mov T2,qword [T1+ClosureLayout::kUpValueOffset]
//|  mov reg, qword [T2+index*8]
//|.endmacro

//|.macro StUV,index,reg
//|  mov T1,qword [RUNTIME+RuntimeLayout::kCurClsOffset]
//|  mov T2,qword [T1+ClosureLayout::kUpValueOffset]
//|  mov qword [T2+index*8], reg
//|.endmacro

// ----------------------------------------------
// Heap value related stuff

// This byte offset in little endian for type pattern inside of
// heap object header
#define HOH_TYPE_OFFSET 7

// Set a pointer into a register , this is really painful
//|.macro StHeap,val

//|.if 0
//|  mov T1,Value::FLAG_HEAP
//|  shl T1,48
//|  or val,T1
//|.else
//|  or  val,qword [->ValueHeapMaskStore]
//|.endif

//|.endmacro

// Load a pointer from Value object , assume this object
// is a pointer type
//|.macro LdPtrFromV,dest,val
//|.if 1
//|  mov dest,Value::FLAG_HEAP_UNMASK
//|  shl dest,48
//|  or  dest,val
//|.else
//|  mov dest,val
//|  or  dest,qword [->ValueHeapLoadMask]
//|.endif
//|.endmacro

//|.macro DerefPtrFromV,v
//|  and v, qword [->ValueHeapLoadMask]
//|.endmacro

// It is painful to load a string into its Value format
//|.macro LdStrV,val,index
//|  mov T1 , qword [PROTO]
//|  mov T2 , qword [T1+PrototypeLayout::kStringTableOffset]
//|  mov val, qword [T2+index*8]
//|  StHeap val
//|.endmacro

//|.macro LdStr,val,index
//|  mov T1 , qword [PROTO]
//|  mov T2 , qword [T1+PrototypeLayout::kStringTableOffset]
//|  mov val, qword [T2+index*8]
//|.endmacro

// Check whether a Value is a HeapObject
//|.macro CheckHeap,val,fail_label
//|  mov T1,val
//|  shr T1,48
//|  cmp T1L, Value::FLAG_HEAP
//|  jne fail_label
//|.endmacro

// General macro to check a heap object is certain type
//|.macro CheckHeapPtrT,val,pattern,fail_label
//|  cmp byte [val-HOH_TYPE_OFFSET], pattern
//|  jne fail_label
//|.endmacro

//|.macro CheckHeapT,val,pattern,fail_label
//|  and val,qword [->ValueHeapMaskLoad]
//|  mov val, qword [val]
//|  CheckHeapPtrT val,pattern,fail_label
//|.endmacro

// -------------------------------------------------------------------------
// Object bit pattern

#define OBJECT_BIT_PATTERN TYPE_OBJECT
#define LIST_BIT_PATTERN TYPE_LIST
#define SSO_BIT_PATTERN TYPE_STRING
#define CLOSURE_BIT_PATTERN TYPE_CLOSURE
#define EXTENSION_BIT_PATTERN TYPE_EXTENSION

// -------------------------------------------------------------------------
// Check an *GCRef* is Object or not

//|.macro CheckObj,val,fail_label
//|  CheckHeapT val,OBJECT_BIT_PATTERN,fail_label
//|.endmacro

//|.macro CheckObjV,val,fail_label
//|  CheckHeap val,fail_label
//|  CheckObj val,fail_label
//|.endmacro

// --------------------------------------------------------------------------
// Check an *GCRef* is List or not

//|.macro CheckList,val,fail_label
//|  CheckHeapT val,LIST_BIT_PATTERN,fail_label
//|.endmacro

//|.macro CheckListV,val,fail_label
//|  CheckHeap val,fail_label
//|  CheckObj val,fail_label
//|.endmacro

// --------------------------------------------------------------------------
// Check a *GCRef* is SSO or not , not stored in Value

// reg : pointer of String
//|.macro CheckSSO,reg,fail
//|  mov reg, qword [reg]
//|  CheckHeapPtrT reg,SSO_BIT_PATTERN,fail
// dereference *once* from String* --> SSO*
//|  mov reg, qword [reg]
//|.endmacro

//|.macro CheckSSOV,reg,fail
//|  CheckHeap reg,fail
//|  CheckHeapT,reg,SSO_BIT_PATTERN,fail
// dereference *once* from String* --> SSO*
//|  mov reg, qword [reg]
//|.endmacro

// If fail, reg will be set to store the value of that
// actual pointer points to a *unknown* heap object;
// otherwise reg will be set to store the value of pointer
// for that SSO object
//|.macro CheckSSORaw,reg,fail
//|  and reg,qword [->ValueHeapMaskLoad]
//|  mov reg,qword [reg]
//|  cmp byte [reg-HOH_TYPE_OFFSET], SSO_BIT_PATTERN
//|  jne fail
//|  mov reg,qword [reg]
//|.endmacro

#define INTERP_HELPER_LIST(__)               \
  /* arithmetic */                           \
  __(INTERP_START,InterpStart)               \
  __(INTERP_FAIL ,InterpFail)                \
  __(INTERP_RETURN,InterpReturn)             \
  __(INTERP_ARITH_REALL,InterpArithRealL)    \
  __(INTERP_ARITH_REALR,InterpArithRealR)    \
  __(INTERP_ARITH_VV,InterpArithVV)          \
  __(INTERP_POW_SLOWVR,InterpPowSlowVR)      \
  __(INTERP_POW_SLOWRV,InterpPowSlowRV)      \
  __(INTERP_POW_SLOWVV,InterpPowSlowVV)      \
  __(DIV_BY_ZERO,DivByZero)                  \
  /* comparison */                           \
  __(INTERP_COMPARERV,InterpCompareRV)       \
  __(INTERP_COMPAREVR,InterpCompareVR)       \
  __(INTERP_COMPAREVV,InterpCompareVV)       \
  /* property get/set */                     \
  __(INTERP_PROPGET_NOTFOUND,InterpPropGetNotFound)   \
  __(INTERP_PROPGET,InterpPropGet)                    \
  __(INTERP_IDX_GETI,InterpIdxGetI)                   \
  __(INTERP_IDX_GET ,InterpIdxGet )                   \
  __(INTERP_IDX_SETI,InterpIdxSetI)                   \
  __(INTERP_IDX_SET ,InterpIdxSet )                   \
  __(INTERP_PROP_NEEDOBJECT ,InterpNeedObject)        \
  __(INTERP_IDX_OUTOFBOUND_GET,InterpIdxOutOfBoundGet)\
  __(INTERP_IDX_OUTOFBOUND_SET,InterpIdxOutOfBoundSet)\
  /* ---- Debug Helper ---- */                        \
  __(PRINT_OP,PrintOP)                                \
  __(PRINT2  ,Print2 )                                \
  __(PRINT64 ,Print64)                                \
  __(PRINTF  ,PrintF )

enum {
  INTERP_HELPER_DUMMY = SIZE_OF_BYTECODE,

#define __(A,B) A,
  INTERP_HELPER_LIST(__)
#undef __

  DASM_GROWABLE_PC_SIZE
};

#define INTERP_HELPER_START (INTERP_HELPER_DUMMY+1)
#define INTERP_HELPER_SIZE (DASM_GROWABLE_PC_SIZE-INTERP_HELPER_ROUTINE_ENUM-1)

const char* GetInterpHelperName( int idx ) {
  switch(idx) {
#define __(A,B) case A: return #B;
    INTERP_HELPER_LIST(__)
    default:
      lava_unreachF("unknown helper with index:%d",idx);
      return NULL;
#undef __ // __
  }
}

/* -----------------------------------------------------------
 * Macro Interfaces for Dynasm                               |
 * ----------------------------------------------------------*/
#define Dst (&(bctx->dasm_ctx))

/* -----------------------------------------------------------
 * Interpreter Prolog                                        |
 * ----------------------------------------------------------*/
void GenerateInterpMisc( BuildContext* bctx ) {
  /* -------------------------------------------
   * Constant value needed for the interpreter |
   * ------------------------------------------*/
  // Align with cache line ???
  //|.data
  dasm_put(Dst, 0);
#line 1012 "src/interpreter/bytecode-interpreter.dasc"
  //|->ValueHeapMaskStore:
  //|.dword Value::TAG_HEAP_STORE_MASK_LOWER,Value::TAG_HEAP_STORE_MASK_HIGHER // 8 bytes
  dasm_put(Dst, 2, Value::TAG_HEAP_STORE_MASK_LOWER, Value::TAG_HEAP_STORE_MASK_HIGHER);
#line 1014 "src/interpreter/bytecode-interpreter.dasc"

  //|->ValueHeapMaskLoad:
  //|.dword Value::TAG_HEAP_LOAD_MASK_LOWER,Value::TAG_HEAP_LOAD_MASK_HIGHER   // 8 bytes
  dasm_put(Dst, 7, Value::TAG_HEAP_LOAD_MASK_LOWER, Value::TAG_HEAP_LOAD_MASK_HIGHER);
#line 1017 "src/interpreter/bytecode-interpreter.dasc"

  //|->FlagTrueConst:
  //|.dword Value::FLAG_TRUE // 4 bytes
  dasm_put(Dst, 12, Value::FLAG_TRUE);
#line 1020 "src/interpreter/bytecode-interpreter.dasc"

  //|->FlagFalseConst:
  //|.dword Value::FLAG_FALSE // 4 bytes
  dasm_put(Dst, 16, Value::FLAG_FALSE);
#line 1023 "src/interpreter/bytecode-interpreter.dasc"

  //|->RealZero:
  //|.dword 0,0  // 8 btyes
  dasm_put(Dst, 20);
#line 1026 "src/interpreter/bytecode-interpreter.dasc"

  //|.code
  dasm_put(Dst, 31);
#line 1028 "src/interpreter/bytecode-interpreter.dasc"

  /* -------------------------------------------
   * Start of the code                         |
   * ------------------------------------------*/

  //|.macro interp_prolog
  //|  sub   rsp, RESERVE_RSP             // make room on the stack

  //|  mov qword SAVED_R12,r12            // runtime
  //|  mov qword SAVED_R13,r13            // proto
  //|  mov qword SAVED_R14,r14            // stack
  //|  mov qword SAVED_R15,r15            // dispatch
  //|  mov qword SAVED_RBP,rbp            // PC
  //|  mov qword SAVED_RBX,rbx            // used by ARG2 , this may be changed in the future
  //|.endmacro

  //|.macro interp_epilog
  //|  mov r12, qword SAVED_R12
  //|  mov r13, qword SAVED_R13
  //|  mov r14, qword SAVED_R14
  //|  mov r15, qword SAVED_R15
  //|  mov rbp, qword SAVED_RBP
  //|  mov rbx, qword SAVED_RBX

  //|  add rsp, RESERVE_RSP
  //|.endmacro

  /* -------------------------------------------
   * Interpreter Prolog                        |
   * ------------------------------------------*/
  //|=> INTERP_START:
  //|->InterpStart:
  dasm_put(Dst, 33,  INTERP_START);
#line 1060 "src/interpreter/bytecode-interpreter.dasc"
  // save all callee saved register since we use them to keep tracking of
  // our most important data structure
  //|  interp_prolog
  dasm_put(Dst, 37);
#line 1063 "src/interpreter/bytecode-interpreter.dasc"

  //|  mov RUNTIME ,CARG1                 // runtime
  //|  mov PROTO   ,CARG2                 // proto
  //|  mov STK     ,CARG3                 // stack
  //|  mov PC      ,CARG4                 // pc
  //|  mov DISPATCH,CARG5                 // dispatch
  dasm_put(Dst, 73);
#line 1069 "src/interpreter/bytecode-interpreter.dasc"

  //|  mov qword SAVED_PC,CARG4           // save the *start* of bc array
  dasm_put(Dst, 91);
#line 1071 "src/interpreter/bytecode-interpreter.dasc"
  // run
  //|  Dispatch
  dasm_put(Dst, 96);
#line 1073 "src/interpreter/bytecode-interpreter.dasc"

  /* -------------------------------------------
   * Interpreter exit handler                  |
   * ------------------------------------------*/
  //|=> INTERP_FAIL:
  //|->InterpFail:
  //|  xor eax,eax
  //|  interp_epilog
  //|  ret
  dasm_put(Dst, 116,  INTERP_FAIL);
#line 1082 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_RETURN:
  //|->InterpReturn:
  //|  mov rax, qword [ACC]
  //|  mov qword [RUNTIME+RuntimeLayout::kRetOffset],rax
  //|  mov rax,1
  dasm_put(Dst, 157,  INTERP_RETURN, RuntimeLayout::kRetOffset);
#line 1088 "src/interpreter/bytecode-interpreter.dasc"

  //|  interp_epilog
  //|  ret
  dasm_put(Dst, 121);
#line 1091 "src/interpreter/bytecode-interpreter.dasc"
}

/* ------------------------------------------
 * helper functions/routines generation     |
 * -----------------------------------------*/

// ----------------------------------------
// helper macros
// ----------------------------------------
//|.macro retbool
//|  test eax,eax
//|  je ->InterpFail
//|  Dispatch
//|.endmacro

// saving the current PC into the Runtime object, this is
// needed for GC to figure out the correct active register
// layout during the GC marking phase
//|.macro savepc
//|  mov qword [RUNTIME+RuntimeLayout::kCurPCOffset], PC
//|.endmacro

void GenerateHelper( BuildContext* bctx ) {

  /* ----------------------------------------
   * InterpArithXXX                         |
   * ---------------------------------------*/
  //|=> INTERP_ARITH_REALL:
  //|->InterpArithRealL:
  //|  savepc
  //|  mov CARG1,RUNTIME
  //|  LdRealV CARG2,ARG2F
  //|  mov CARG3, qword [STK+ARG3F*8]
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterDoArithmetic
  dasm_put(Dst, 182,  INTERP_ARITH_REALL, RuntimeLayout::kCurPCOffset, PrototypeLayout::kRealTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic))) {
  dasm_put(Dst, 213);
   } else {
     lava_warn("%s","Function InterpreterDoArithmetic address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic))>>32));
   }
#line 1126 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1127 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_ARITH_REALR:
  //|->InterpArithRealR:
  //|  savepc
  //|  mov CARG1,RUNTIME
  //|  mov CARG2,qword [STK+ARG2F*8]
  //|  LdRealV CARG3,ARG3F
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterDoArithmetic
  dasm_put(Dst, 252,  INTERP_ARITH_REALR, RuntimeLayout::kCurPCOffset, PrototypeLayout::kRealTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic))) {
  dasm_put(Dst, 213);
   } else {
     lava_warn("%s","Function InterpreterDoArithmetic address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic))>>32));
   }
#line 1136 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1137 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_ARITH_VV:
  //|->InterpArithVV:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG1F*8]
  //|  mov CARG3, qword [STK+ARG2F*8]
  //|  lea CARG4, [STK+ARG3F*8] // ARG3F == CARG4
  //|  fcall InterpreterDoArithmetic
  dasm_put(Dst, 283,  INTERP_ARITH_VV, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic))) {
  dasm_put(Dst, 213);
   } else {
     lava_warn("%s","Function InterpreterDoArithmetic address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoArithmetic))>>32));
   }
#line 1146 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1147 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_POW_SLOWRV:
  //|->InterpPowSlowRV:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  LdRealV CARG2,ARG2F
  //|  mov CARG3,qword [STK+ARG3F*8]
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterPow
  dasm_put(Dst, 308,  INTERP_POW_SLOWRV, RuntimeLayout::kCurPCOffset, PrototypeLayout::kRealTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterPow))) {
  dasm_put(Dst, 339);
   } else {
     lava_warn("%s","Function InterpreterPow address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterPow)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterPow))>>32));
   }
#line 1156 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1157 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_POW_SLOWVR:
  //|->InterpPowSlowVR:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  LdRealV CARG3,ARG3F
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterPow
  dasm_put(Dst, 344,  INTERP_POW_SLOWVR, RuntimeLayout::kCurPCOffset, PrototypeLayout::kRealTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterPow))) {
  dasm_put(Dst, 339);
   } else {
     lava_warn("%s","Function InterpreterPow address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterPow)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterPow))>>32));
   }
#line 1166 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1167 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_POW_SLOWVV:
  //|->InterpPowSlowVV:
  //|  savepc
  //|  instr_D
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  mov CARG3, qword [STK+ARG3F*8]
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterPow
  dasm_put(Dst, 375,  INTERP_POW_SLOWVV, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterPow))) {
  dasm_put(Dst, 339);
   } else {
     lava_warn("%s","Function InterpreterPow address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterPow)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterPow))>>32));
   }
#line 1177 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1178 "src/interpreter/bytecode-interpreter.dasc"

  /* -------------------------------------------
   * Interp Arithmetic Exception               |
   * ------------------------------------------*/
  //|=> DIV_BY_ZERO:
  //|->DivByZero:
  //|  mov CARG1,RUNTIME
  //|  lea CARG2,[PC-4]
  //|  fcall InterpreterDivByZero
  dasm_put(Dst, 416,  DIV_BY_ZERO);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDivByZero))) {
  dasm_put(Dst, 428);
   } else {
     lava_warn("%s","Function InterpreterDivByZero address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDivByZero)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDivByZero))>>32));
   }
#line 1187 "src/interpreter/bytecode-interpreter.dasc"
  //|  jmp ->InterpFail
  dasm_put(Dst, 433);
#line 1188 "src/interpreter/bytecode-interpreter.dasc"

  /* -------------------------------------------
   * Interp Comparison                         |
   * ------------------------------------------*/
  //|=> INTERP_COMPARERV:
  //|->InterpCompareRV:
  //|  savepc
  //|  mov CARG1,RUNTIME
  //|  LdRealV CARG2,ARG2F
  //|  mov CARG3, qword [STK+ARG2F*8]
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterDoCompare
  dasm_put(Dst, 438,  INTERP_COMPARERV, RuntimeLayout::kCurPCOffset, PrototypeLayout::kRealTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoCompare))) {
  dasm_put(Dst, 469);
   } else {
     lava_warn("%s","Function InterpreterDoCompare address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoCompare)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoCompare))>>32));
   }
#line 1200 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1201 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_COMPAREVR:
  //|->InterpCompareVR:
  //|  savepc
  //|  mov CARG1,RUNTIME
  //|  mov CARG2,qword [STK+ARG2F*8]
  //|  LdRealV CARG3,ARG3F
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterDoCompare
  dasm_put(Dst, 474,  INTERP_COMPAREVR, RuntimeLayout::kCurPCOffset, PrototypeLayout::kRealTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoCompare))) {
  dasm_put(Dst, 469);
   } else {
     lava_warn("%s","Function InterpreterDoCompare address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoCompare)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoCompare))>>32));
   }
#line 1210 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1211 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_COMPAREVV:
  //|->InterpCompareVV:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  mov CARG3, qword [STK+ARG3F*8]
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterDoCompare
  dasm_put(Dst, 505,  INTERP_COMPAREVV, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoCompare))) {
  dasm_put(Dst, 469);
   } else {
     lava_warn("%s","Function InterpreterDoCompare address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoCompare)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoCompare))>>32));
   }
#line 1220 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1221 "src/interpreter/bytecode-interpreter.dasc"

  /* -------------------------------------------------
   * Property Get/Set                                |
   * ------------------------------------------------*/
  //|=> INTERP_PROPGET:
  //|->InterpPropGet:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  LdStr CARG3, ARG3F
  //|  lea CARG4, [STK+ARG1F*8]
  //|  fcall InterpreterPropGet
  dasm_put(Dst, 530,  INTERP_PROPGET, RuntimeLayout::kCurPCOffset, PrototypeLayout::kStringTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterPropGet))) {
  dasm_put(Dst, 563);
   } else {
     lava_warn("%s","Function InterpreterPropGet address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterPropGet)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterPropGet))>>32));
   }
#line 1233 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1234 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_PROPGET_NOTFOUND:
  //|->InterpPropGetNotFound:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  LdStr CARG3,ARG3F
  //|  fcall InterpreterPropGetNotFound
  dasm_put(Dst, 568,  INTERP_PROPGET_NOTFOUND, RuntimeLayout::kCurPCOffset, PrototypeLayout::kStringTableOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterPropGetNotFound))) {
  dasm_put(Dst, 597);
   } else {
     lava_warn("%s","Function InterpreterPropGetNotFound address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterPropGetNotFound)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterPropGetNotFound))>>32));
   }
#line 1242 "src/interpreter/bytecode-interpreter.dasc"
  //|  jmp ->InterpFail
  dasm_put(Dst, 433);
#line 1243 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_PROP_NEEDOBJECT:
  //|->InterpPropNeedObject:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  fcall InterpreterPropNeedObject
  dasm_put(Dst, 602,  INTERP_PROP_NEEDOBJECT, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterPropNeedObject))) {
  dasm_put(Dst, 619);
   } else {
     lava_warn("%s","Function InterpreterPropNeedObject address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterPropNeedObject)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterPropNeedObject))>>32));
   }
#line 1250 "src/interpreter/bytecode-interpreter.dasc"
  //|  jmp ->InterpFail
  dasm_put(Dst, 433);
#line 1251 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_IDX_GETI:
  //|->InterpIdxGetI:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  mov CARG3L,ARG3
  //|  lea CARG4, qword [STK+ARG1F*8]
  //|  fcall InterpreterIdxGetI
  dasm_put(Dst, 624,  INTERP_IDX_GETI, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterIdxGetI))) {
  dasm_put(Dst, 647);
   } else {
     lava_warn("%s","Function InterpreterIdxGetI address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterIdxGetI)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterIdxGetI))>>32));
   }
#line 1260 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1261 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_IDX_SETI:
  //|->InterpIdxSetI:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG1F*8]
  //|  mov CARG3L,ARG2
  //|  mov CARG4, qword [STK+ARG3F*8]
  //|  fcall InterpreterIdxSetI
  dasm_put(Dst, 652,  INTERP_IDX_SETI, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterIdxSetI))) {
  dasm_put(Dst, 675);
   } else {
     lava_warn("%s","Function InterpreterIdxSetI address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterIdxSetI)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterIdxSetI))>>32));
   }
#line 1270 "src/interpreter/bytecode-interpreter.dasc"
  //|  retbool
  dasm_put(Dst, 226);
#line 1271 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_IDX_OUTOFBOUND_SET:
  //|->InterpIdxOutOfBoundSet:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG2F*8]
  //|  mov CARG3L, ARG3
  //|  fcall InterpreterIdxOutOfBound
  dasm_put(Dst, 680,  INTERP_IDX_OUTOFBOUND_SET, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterIdxOutOfBound))) {
  dasm_put(Dst, 699);
   } else {
     lava_warn("%s","Function InterpreterIdxOutOfBound address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterIdxOutOfBound)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterIdxOutOfBound))>>32));
   }
#line 1279 "src/interpreter/bytecode-interpreter.dasc"
  //|  jmp ->InterpFail
  dasm_put(Dst, 433);
#line 1280 "src/interpreter/bytecode-interpreter.dasc"

  //|=> INTERP_IDX_OUTOFBOUND_GET:
  //|->InterpIdxOutOfBoundGet:
  //|  savepc
  //|  mov CARG1, RUNTIME
  //|  mov CARG2, qword [STK+ARG1F*8]
  //|  mov CARG3L, ARG2
  //|  fcall InterpreterIdxOutOfBound
  dasm_put(Dst, 704,  INTERP_IDX_OUTOFBOUND_GET, RuntimeLayout::kCurPCOffset);
   if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterIdxOutOfBound))) {
  dasm_put(Dst, 699);
   } else {
     lava_warn("%s","Function InterpreterIdxOutOfBound address is not in 0-2GB");
  dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterIdxOutOfBound)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterIdxOutOfBound))>>32));
   }
#line 1288 "src/interpreter/bytecode-interpreter.dasc"
  //|  jmp ->InterpFail
  dasm_put(Dst, 433);
#line 1289 "src/interpreter/bytecode-interpreter.dasc"
}

void GenerateOneBytecode( BuildContext* bctx, Bytecode bc ) {
  switch(bc) {
    /** =====================================================
     *  Call handling                                       |
     *  ====================================================*/
    case BC_RETNULL:
      //|=> bc:
      //|  instr_X
      //|  mov dword [STK+ACCFIDX],Value::FLAG_NULL
      //|  jmp ->InterpReturn
      dasm_put(Dst, 723,  bc, Value::FLAG_NULL);
#line 1301 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_RET:
      //|=> bc:
      //|  instr_X
      //|  jmp ->InterpReturn
      dasm_put(Dst, 738,  bc);
#line 1307 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /** =====================================================
     *  Register Move                                       |
     *  ====================================================*/
    case BC_MOVE:
      //|=> bc:
      //|  instr_E
      //|  mov ARG3F,qword [STK+ARG2F*8]
      //|  mov qword [STK+ARG1F*8],ARG3F
      //|  Dispatch
      dasm_put(Dst, 744,  bc);
#line 1318 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /** =====================================================
     *  Constant Loading                                    |
     *  ====================================================*/
    case BC_LOAD0:
      //|=> bc:
      //|  instr_F
      //|  xorpd xmm0,xmm0
      //|  movsd qword[STK+ARG1F*8], xmm0
      //|  Dispatch
      dasm_put(Dst, 779,  bc);
#line 1329 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_LOAD1:
      //|=> bc:
      //|  instr_F
      //|  rconst_one xmm0
      //|  movsd qword[STK+ARG1F*8], xmm0
      //|  Dispatch
      dasm_put(Dst, 814,  bc, (unsigned int)((static_cast<std::uint64_t>(0x3ff00000)<<32)), (unsigned int)(((static_cast<std::uint64_t>(0x3ff00000)<<32))>>32));
#line 1337 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_LOADN1:
      //|=> bc:
      //|  instr_F
      //|  rconst_neg_one xmm0
      //|  movsd qword[STK+ARG1F*8], xmm0
      //|  Dispatch
      dasm_put(Dst, 814,  bc, (unsigned int)((static_cast<std::uint64_t>(0xbff00000)<<32)), (unsigned int)(((static_cast<std::uint64_t>(0xbff00000)<<32))>>32));
#line 1345 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_LOADR:
      //|=> bc:
      //|  instr_E
      //|  LdReal xmm0,ARG2F
      //|  movsd qword [STK+ARG1F*8],xmm0
      //|  Dispatch
      dasm_put(Dst, 854,  bc, PrototypeLayout::kRealTableOffset);
#line 1353 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_LOADNULL:
      //|=> bc:
      //|  instr_F
      //|  mov dword [STK+ARG1F*8+4],Value::FLAG_NULL
      //|  Dispatch
      dasm_put(Dst, 901,  bc, Value::FLAG_NULL);
#line 1360 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_LOADTRUE:
      //|=> bc:
      //|  instr_F
      //|  mov dword [STK+ARG1F*8+4],Value::FLAG_TRUE
      //|  Dispatch
      dasm_put(Dst, 901,  bc, Value::FLAG_TRUE);
#line 1367 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_LOADFALSE:
      //|=> bc:
      //|  instr_F
      //|  mov dword [STK+ARG1F*8+4],Value::FLAG_FALSE
      //|  Dispatch
      dasm_put(Dst, 901,  bc, Value::FLAG_FALSE);
#line 1374 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_LOADSTR:
      //|=> bc:
      //|  instr_E
      //|  LdStrV LREG,ARG2F
      //|  mov qword [STK+ARG1F*8],LREG
      //|  Dispatch
      dasm_put(Dst, 931,  bc, PrototypeLayout::kStringTableOffset);
#line 1382 "src/interpreter/bytecode-interpreter.dasc"
      break;

    // -------------------------------------------------
    // Loading List/Object/Clousure
    //
    //
    // For these bytecodes, no optimization is performed but
    // directly yield back to C++ function to do the job. It
    // has no points to optimize these cases since they are
    // small amount of bytecodes and also complicated to write
    // in assembly without too much gain
    //
    //
    // To reduce ICache stress, the decode routine is *not*
    // placed inlined with each BC_XXX here but in the slow
    // path. This is purposely to make the main part of
    // interpreter to be small which helps about the icache
    // footprint of hot code
    // ------------------------------------------------*/
    case BC_LOADLIST0:
      //|=> bc:
      //|  instr_F
      //|  savepc
      //|  mov CARG1,RUNTIME
      //|  lea CARG2,[STK+ARG1F*8]
      //|  fcall InterpreterDoLoadList0
      dasm_put(Dst, 979,  bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList0))) {
      dasm_put(Dst, 997);
       } else {
         lava_warn("%s","Function InterpreterDoLoadList0 address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList0)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList0))>>32));
       }
#line 1408 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1409 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LOADLIST1:
      //|=>bc:
      //|  instr_E
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  fcall InterpreterDoLoadList1
      dasm_put(Dst, 1002, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList1))) {
      dasm_put(Dst, 1027);
       } else {
         lava_warn("%s","Function InterpreterDoLoadList1 address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList1)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList1))>>32));
       }
#line 1418 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1419 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LOADLIST2:
      //|=>bc:
      //|  instr_D
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  mov CARG4, qword [STK+ARG3F*8]
      //|  fcall InterpreterDoLoadList2
      dasm_put(Dst, 1032, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList2))) {
      dasm_put(Dst, 1071);
       } else {
         lava_warn("%s","Function InterpreterDoLoadList2 address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList2)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoLoadList2))>>32));
       }
#line 1429 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1430 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_NEWLIST:
      //|=>bc:
      //|  jmp ->InterpNewList
      //|  instr_B
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3L, ARG2
      //|  fcall InterpreterDoNewList
      dasm_put(Dst, 1076, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoNewList))) {
      dasm_put(Dst, 1104);
       } else {
         lava_warn("%s","Function InterpreterDoNewList address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoNewList)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoNewList))>>32));
       }
#line 1440 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1441 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_ADDLIST:
      //|=>bc:
      //|  instr_E
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  fcall InterpreterDoAddList
      dasm_put(Dst, 1002, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoAddList))) {
      dasm_put(Dst, 1109);
       } else {
         lava_warn("%s","Function InterpreterDoAddList address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoAddList)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoAddList))>>32));
       }
#line 1450 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1451 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LOADOBJ0:
      //|=>bc:
      //|  instr_F
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  fcall InterpreterDoLoadObj0
      dasm_put(Dst, 979, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadObj0))) {
      dasm_put(Dst, 1114);
       } else {
         lava_warn("%s","Function InterpreterDoLoadObj0 address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadObj0)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoLoadObj0))>>32));
       }
#line 1459 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1460 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LOADOBJ1:
      //|=>bc:
      //|  instr_D
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  mov CARG4, qword [STK+ARG3F*8]
      //|  fcall InterpreterDoLoadObj1
      dasm_put(Dst, 1032, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadObj1))) {
      dasm_put(Dst, 1119);
       } else {
         lava_warn("%s","Function InterpreterDoLoadObj1 address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadObj1)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoLoadObj1))>>32));
       }
#line 1470 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1471 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_NEWOBJ:
      //|=>bc:
      //|  instr_B
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3L, ARG2
      //|  fcall InterpreterDoNewObj
      dasm_put(Dst, 1124, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoNewObj))) {
      dasm_put(Dst, 1148);
       } else {
         lava_warn("%s","Function InterpreterDoNewObj address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoNewObj)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoNewObj))>>32));
       }
#line 1480 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1481 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_ADDOBJ:
      //|=>bc:
      //|  instr_D
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  mov CARG4, qword [STK+ARG3F*8]
      //|  fcall InterpreterDoAddObj
      dasm_put(Dst, 1032, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoAddObj))) {
      dasm_put(Dst, 1153);
       } else {
         lava_warn("%s","Function InterpreterDoAddObj address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoAddObj)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoAddObj))>>32));
       }
#line 1491 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1492 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LOADCLS:
      //|=>bc:
      //|  instr_C
      //|  savepc
      //|  mov CARG1,RUNTIME
      //|  mov CARG2, STK
      //|  mov CARG3L, ARG2
      //|  lea CARG4 , [STK+ARG1F*8]
      //|  fcall InterpreterDoLoadCls
      dasm_put(Dst, 1158, bc, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadCls))) {
      dasm_put(Dst, 1186);
       } else {
         lava_warn("%s","Function InterpreterDoLoadCls address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoLoadCls)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoLoadCls))>>32));
       }
#line 1502 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 1503 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /** =====================================================
     *  Arith XV                                            |
     *  ====================================================*/
    //|.macro arith_rv,BC,slow_path,instr
    //|  instr_D
    //|  mov RREG, qword [STK+ARG3F*8]

    // Use arg3 as temporary in favoer over T1/T2
    //|.if CHECK_NUMBER_MEMORY
    //|  mov T0L, dword[STK+ARG3F*8+4]
    //|.else
    //|  mov T0,RREG
    //|  shr T0,32
    //|.endif

    //|  cmp T0L, Value::FLAG_REAL
    //|  jnb ->slow_path

    //|  LdReal xmm0,ARG2F
    //|  movd xmm1, RREG
    //|  instr xmm0,xmm1
    //|  StReal ARG1F,xmm0
    //|  Dispatch
    //|.endmacro

    case BC_ADDRV:
      //|=>bc:
      //|  arith_rv BC_ADDRV,InterpArithRealL,addsd
      dasm_put(Dst, 1191, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1533 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_SUBRV:
      //|=>bc:
      //|  arith_rv BC_SUBRV,InterpArithRealL,subsd
      dasm_put(Dst, 1278, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1538 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_MULRV:
      //|=>bc:
      //|  arith_rv BC_MULRV,InterpArithRealL,mulsd
      dasm_put(Dst, 1365, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1543 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_DIVRV:
      //|=>bc:
      //|  arith_rv BC_DIVRV,InterpArithRealL,divsd
      dasm_put(Dst, 1452, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1548 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /* =========================================================
     * Arith VX                                                |
     * ========================================================*/
    //|.macro arith_vr,BC,slow_path,instr
    //|  instr_D
    //|  mov LREG,qword [STK+ARG2F*8]

    //|.if CHECK_NUMBER_MEMORY
    //|  mov T0L ,dword [STK+ARG2F*8+4]
    //|.else
    //|  mov T0,LREG
    //|  shr T0,32
    //|.endif

    //|  cmp T0L,Value::FLAG_REAL
    //|  jnb ->slow_path

    //|  movd xmm0,LREG
    //|  LdReal xmm1,ARG3F
    //|  instr xmm0,xmm1
    //|  StReal ARG1F,xmm0
    //|  Dispatch
    //|.endmacro


    case BC_ADDVR:
      //|=> bc:
      //|  arith_vr BC_ADDVR,InterpArithRealR,addsd
      dasm_put(Dst, 1539,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1578 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_SUBVR:
      //|=> bc:
      //|  arith_vr BC_SUBVR,InterpArithRealR,subsd
      dasm_put(Dst, 1627,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1583 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_MULVR:
      //|=> bc:
      //|  arith_vr BC_MULVR,InterpArithRealR,mulsd
      dasm_put(Dst, 1715,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1588 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_DIVVR:
      //|=> bc:
      //|  arith_vr BC_DIVVR,InterpArithRealR,divsd
      dasm_put(Dst, 1803,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset);
#line 1593 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /* ========================================================
     * ArithVV
     *
     * The arithVV is also optimized for common path here.
     * We inline all numeric calculation cases, int/real.
     * Other cases will be pushed back to call C++ function
     * which may be extended to support meta function call
     *
     * ========================================================*/
    // perform VV calaculation based on instruction
    //|.macro arith_vv,BC,instrR
    //|=> BC:
    //|  instr_D

    // check the lhs to be integer or not
    //|  mov LREG,qword [STK+ARG2F*8]
    //|  cmp LREGL,Value::FLAG_REAL
    //|  jnb ->InterpArithVV

    //| // real && xx
    //|  mov RREG,qword [STK+ARG3F*8]
    //|  cmp RREGL,Value::FLAG_REAL
    //|  jnb ->InterpArithVV

    //|  movsd xmm0, qword [STK+ARG2F*8]
    //|  instrR xmm0, qword [STK+ARG3F*8]
    //|  StReal ARG1F,xmm0
    //|  Dispatch
    //|.endmacro

    case BC_ADDVV:
      //|  arith_vv BC_ADDVV,addsd
      dasm_put(Dst, 1891,  BC_ADDVV, Value::FLAG_REAL, Value::FLAG_REAL);
#line 1627 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_SUBVV:
      //|  arith_vv BC_SUBVV,subsd
      dasm_put(Dst, 1973,  BC_SUBVV, Value::FLAG_REAL, Value::FLAG_REAL);
#line 1630 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_MULVV:
      //|  arith_vv BC_MULVV,mulsd
      dasm_put(Dst, 2055,  BC_MULVV, Value::FLAG_REAL, Value::FLAG_REAL);
#line 1633 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_DIVVV:
      //|  arith_vv BC_DIVVV,divsd
      dasm_put(Dst, 2137,  BC_DIVVV, Value::FLAG_REAL, Value::FLAG_REAL);
#line 1636 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /* =============================================================
     * MODXX
     *
     *   Similar implementation like Lua not Luajit. Return casted
     *   integer's mod value instead of fmod style value. BTW, fmod
     *   is really slow
     *
     * ============================================================*/


    case BC_MODVR:
      //|=>bc:
      //|  instr_D
      dasm_put(Dst, 2219, bc);
#line 1651 "src/interpreter/bytecode-interpreter.dasc"

      //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      //|  jnb ->InterpArithVV
      dasm_put(Dst, 2237, Value::FLAG_REAL);
#line 1654 "src/interpreter/bytecode-interpreter.dasc"

      //|  LdReal2Int ARG3,ARG3F,T0
      //|  cvtsd2si eax ,qword [STK+ARG2F*8]  // ARG2F == rax
      dasm_put(Dst, 2249, PrototypeLayout::kRealTableOffset);
#line 1657 "src/interpreter/bytecode-interpreter.dasc"

      //|.if CHECK_DIV_BY_ZERO
      //|  test ARG3,ARG3
      //|  je ->DivByZero
      //|.endif
      dasm_put(Dst, 2269);
#line 1662 "src/interpreter/bytecode-interpreter.dasc"

      //|  cdq
      //|  idiv     ARG3
      //|  StRealFromInt ARG1F,edx
      //|  Dispatch
      dasm_put(Dst, 2276);
#line 1667 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_MODRV:
      //|=>bc:
      //|  instr_D
      dasm_put(Dst, 2219, bc);
#line 1672 "src/interpreter/bytecode-interpreter.dasc"

      //|  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
      //|  jnb ->InterpArithVV
      dasm_put(Dst, 2313, Value::FLAG_REAL);
#line 1675 "src/interpreter/bytecode-interpreter.dasc"

      //|  LdReal2Int eax,ARG2F,T0  // ARG2F == rax
      //|  cvtsd2si ARG3 ,qword [STK+ARG3F*8]
      dasm_put(Dst, 2325, PrototypeLayout::kRealTableOffset);
#line 1678 "src/interpreter/bytecode-interpreter.dasc"

      //|.if CHECK_DIV_BY_ZERO
      //|  test ARG3,ARG3
      //|  je ->DivByZero
      //|.endif
      dasm_put(Dst, 2269);
#line 1683 "src/interpreter/bytecode-interpreter.dasc"

      //|  cdq
      //|  idiv ARG3
      //|  StRealFromInt ARG1F,edx
      //|  Dispatch
      dasm_put(Dst, 2276);
#line 1688 "src/interpreter/bytecode-interpreter.dasc"

      break;

    case BC_MODVV:
      //|=>bc :
      //|  instr_D
      //|  cmp dword [STK+ARG2F*8+4] , Value::FLAG_REAL
      //|  jnb ->InterpArithVV
      dasm_put(Dst, 2345, bc , Value::FLAG_REAL);
#line 1696 "src/interpreter/bytecode-interpreter.dasc"

      //|  cmp dword [STK+ARG3F*8+4] , Value::FLAG_REAL
      //|  jnb ->InterpArithVV
      dasm_put(Dst, 2313, Value::FLAG_REAL);
#line 1699 "src/interpreter/bytecode-interpreter.dasc"

      //|  cvtsd2si eax, qword [STK+ARG2F*8]  // ARG2F == rax
      //|  cvtsd2si ARG3,qword [STK+ARG3F*8]
      dasm_put(Dst, 2374);
#line 1702 "src/interpreter/bytecode-interpreter.dasc"

      //|.if CHECK_DIV_BY_ZERO
      //|  test ARG3,ARG3
      //|  je ->DivByZero
      //|.endif
      dasm_put(Dst, 2269);
#line 1707 "src/interpreter/bytecode-interpreter.dasc"

      //|  cdq
      //|  idiv ARG3
      //|  StRealFromInt ARG1F,edx
      //|  Dispatch
      dasm_put(Dst, 2276);
#line 1712 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /* ==============================================================
     * POW part
     *
     * Currently we directly use std::pow/pow in libc for simplicity.
     * For numeric type we will directly call pow for other types
     * we will fallback to slow C++ function
     * =============================================================*/

    //|.macro call_pow
    //|  fcall pow
    //|  movsd qword [STK+ARG1F*8], xmm0  // ARG1F is callee saved
    //|.endmacro

    //|.macro arith_pow,REGL,XREG,ARG,slow_pow
    //|  mov REGL,dword [STK+ARG*8+4]
    //|  cmp REGL,Value::FLAG_REAL
    //|  jnb ->slow_pow
    //|  movsd XREG,qword [STK+ARG*8]
    //|  call_pow
    //|  Dispatch
    //|.endmacro

    case BC_POWRV:
      //|=> bc:
      //|  instr_D
      //|  LdReal xmm0,ARG2F
      //|  arith_pow RREGL,xmm1,ARG3F,InterpPowSlowRV
      dasm_put(Dst, 2389,  bc, PrototypeLayout::kRealTableOffset, Value::FLAG_REAL);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(pow))) {
      dasm_put(Dst, 2440);
       } else {
         lava_warn("%s","Function pow address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(pow)), (unsigned int)((reinterpret_cast<std::uintptr_t>(pow))>>32));
       }
      dasm_put(Dst, 787);
#line 1741 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_POWVR:
      //|=> bc:
      //|  instr_D
      //|  LdReal xmm1,ARG3F
      //|  arith_pow LREGL,xmm0,ARG2F,InterpPowSlowVR
      dasm_put(Dst, 2445,  bc, PrototypeLayout::kRealTableOffset, Value::FLAG_REAL);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(pow))) {
      dasm_put(Dst, 2440);
       } else {
         lava_warn("%s","Function pow address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(pow)), (unsigned int)((reinterpret_cast<std::uintptr_t>(pow))>>32));
       }
      dasm_put(Dst, 787);
#line 1748 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_POWVV:
      //|=> bc:
      //|  jmp ->InterpPowSlowVV
      dasm_put(Dst, 2496,  bc);
#line 1753 "src/interpreter/bytecode-interpreter.dasc"
      break;


    /* ====================================================================
     * Comparison
     *
     * Inline numeric comparison and also do promotion inline
     * ===================================================================*/

    /* --------------------------------------------------------------------
     * Comparison XV                                                      |
     * -------------------------------------------------------------------*/
    //|.macro comp_xv,BC,slow_path,false_jmp
    //|  instr_D

    //|  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
    //|  jnb ->slow_path

    //|  LdReal xmm0, ARG2F
    //|  ucomisd xmm0, qword [STK+ARG3F*8]
    // cmov instruction is slower here , doesn't worth it
    //|  false_jmp >1
    //|  mov dword[STK+ARG1F*8+4], Value::FLAG_TRUE
    //|2:
    //|  Dispatch
    //|1:
    //|  mov dword[STK+ARG1F*8+4], Value::FLAG_FALSE
    //|  jmp <2
    //|.endmacro

    case BC_LTRV:
      //|=>bc:
      //|  comp_xv BC_LTRV,InterpCompareRV,jae
      dasm_put(Dst, 2502, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1786 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LERV:
      //|=> bc:
      //|  comp_xv BC_LERV,InterpCompareRV,ja
      dasm_put(Dst, 2593,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1790 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_GTRV:
      //|=>bc:
      //|  comp_xv BC_GTRV,InterpCompareRV,jbe
      dasm_put(Dst, 2684, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1794 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_GERV:
      //|=> bc:
      //|  comp_xv BC_GERV,InterpCompareRV,jb
      dasm_put(Dst, 2775,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1798 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_EQRV:
      //|=> bc:
      //|  comp_xv BC_EQRV,InterpCompareRV,jne
      dasm_put(Dst, 2866,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1802 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_NERV:
      //|=> bc:
      //|  comp_xv BC_NERV,InterpCompareRV,je
      dasm_put(Dst, 2957,  bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1806 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /* --------------------------------------------------------------------
     * Comparison VX                                                      |
     * -------------------------------------------------------------------*/
    //|.macro comp_vx,BC,slow_path,false_jmp
    //|  instr_D

    //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
    //|  jnb ->slow_path

    //|  LdReal xmm1,ARG3F
    //|  movsd xmm0, qword [STK+ARG2F*8]
    //|  ucomisd xmm0,xmm1
    //|  false_jmp >1
    //|  mov dword [STK+ARG1F*8+4], Value::FLAG_TRUE
    //|2:
    //|  Dispatch
    //|1:
    //|  mov dword [STK+ARG1F*8+4], Value::FLAG_FALSE
    //|  jmp <2
    //|.endmacro

    case BC_LTVR:
      //|=>bc:
      //|  comp_vx BC_LTVR,InterpCompareVR,jae
      dasm_put(Dst, 3048, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1832 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LEVR:
      //|=>bc:
      //|  comp_vx BC_LEVR,InterpCompareVR,ja
      dasm_put(Dst, 3144, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1836 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_GTVR:
      //|=>bc:
      //|  comp_vx BC_GTVR,InterpCompareVR,jbe
      dasm_put(Dst, 3240, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1840 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_GEVR:
      //|=>bc:
      //|  comp_vx BC_GEVR,InterpCompareVR,jb
      dasm_put(Dst, 3336, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1844 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_EQVR:
      //|=>bc:
      //|  comp_vx BC_EQVR,InterpCompareVR,jne
      dasm_put(Dst, 3432, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1848 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_NEVR:
      //|=>bc:
      //|  comp_vx BC_NEVR,InterpCompareVR,je
      dasm_put(Dst, 3528, bc, Value::FLAG_REAL, PrototypeLayout::kRealTableOffset, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1852 "src/interpreter/bytecode-interpreter.dasc"
      break;


    /* --------------------------------------------------------
     * comparison VV
     *
     * We do inline type promotion and comparison for all
     * numeric type
     * --------------------------------------------------------*/
    //|.macro comp_vv,BC,false_jmp
    //|  instr_D

    //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
    //|  jnb ->InterpCompareVV

    //|  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
    //|  jnb ->InterpCompareVV

    //|  movsd xmm0, qword [STK+ARG2F*8]
    //|  ucomisd xmm0, qword  [STK+ARG3F*8]
    //|  false_jmp >1
    //|  mov dword [STK+ARG1F*8+4], Value::FLAG_TRUE
    //|2:
    //|  Dispatch
    //|1:
    //|  mov dword [STK+ARG1F*8+4], Value::FLAG_FALSE
    //|  jmp <2
    //|.endmacro

    case BC_LTVV:
      //|=>bc:
      //|  comp_vv,BC_LTVV,jae
      dasm_put(Dst, 3624, bc, Value::FLAG_REAL, Value::FLAG_REAL, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1884 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_LEVV:
      //|=>bc:
      //|  comp_vv,BC_LEVV,ja
      dasm_put(Dst, 3720, bc, Value::FLAG_REAL, Value::FLAG_REAL, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1888 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_GTVV:
      //|=>bc:
      //|  comp_vv,BC_GTVV,jbe
      dasm_put(Dst, 3816, bc, Value::FLAG_REAL, Value::FLAG_REAL, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1892 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_GEVV:
      //|=>bc:
      //|  comp_vv,BC_GEVV,jb
      dasm_put(Dst, 3912, bc, Value::FLAG_REAL, Value::FLAG_REAL, Value::FLAG_TRUE, Value::FLAG_FALSE);
#line 1896 "src/interpreter/bytecode-interpreter.dasc"
      break;

    //|.macro comp_eqne_vv,BC,T,F
    //|  instr_D

    // We fast check numeric number's value. Pay attension that bit
    // comparison is not okay due to the fact we have +0 and -0
    //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
    //|  jnb >3

    //|  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
    //|  jnb >3

    //|  movsd xmm0, qword [STK+ARG2F*8]
    //|  ucomisd xmm0, qword [STK+ARG3F*8]
    //|  jne >1
    //|  mov dword [STK+ARG1F*8+4], T
    //|2:
    //|  Dispatch
    //|1:
    //|  mov dword [STK+ARG1F*8+4], F
    //|  jmp <2

    // Here we mainly do a comparison between other primitive types
    //|3:
    //|  mov LREG, qword [STK+ARG2F*8]
    //|  mov RREG, qword [STK+ARG3F*8]
    //|  mov T0  , LREG
    //|  mov T1  , RREG
    //|  shr LREG, 48
    //|  shr RREG, 48

    //|  cmp LREG, RREG
    //|  jne >4

    // LREG and RREG doesn't match, we need to rule out heap type to
    // actually tell whether LREGL and RREGL are the same or not
    //|  cmp LREGL, Value::FLAG_HEAP
    //|  je >5
    //|  cmp RREGL, Value::FLAG_HEAP
    //|  je >5

    // Okay, both LREGL an RREGL are not heap tag, so we can assert
    // they are equal due to they are primitive type
    //|  mov dword [STK+ARG1F*8+4], T
    //|  jmp <2

    // Primitive type are definitly not equal since they have different
    // type, so we just return *FALSE*
    //|4:
    //|  mov dword [STK+ARG1F*8+4], F
    //|  jmp <2

    // When we reach 5, we know at least one of the operand is a *HEAP*
    // object. We can try to inline a SSO check here or just go back to
    // InterpCompareVV to do the job
    //|5:
    //|  CheckSSORaw T0,>7
    //|  CheckSSORaw T1,>7
    //|  cmp T0,T1
    //|  jne >6
    //|  mov dword [STK+ARG1F*8+4], T
    //|6:
    //|  mov dword [STK+ARG1F*8+4], F
    //|  jmp <2

    // Calls into InterpreterCompareHH
    //|7:
    //|  // T0/T1 stores HeapObject*
    //|  mov CARG1, RUNTIME
    //|  mov CARG2, T0
    //|  mov CARG3, T1
    //|  lea CARG4, [STK+ARG1F*8+4] // where to set the true/false
    //|  fcall InterpreterCompareHH
    //|  test eax,eax
    //|  je ->InterpFail
    //|  Dispatch
    //|.endmacro


    case BC_EQVV:
      //|=>bc:
      //|  comp_eqne_vv BC_EQVV,Value::FLAG_TRUE,Value::FLAG_FALSE
      dasm_put(Dst, 4008, bc, Value::FLAG_REAL, Value::FLAG_REAL, Value::FLAG_TRUE, Value::FLAG_FALSE, Value::FLAG_HEAP);
      dasm_put(Dst, 4146, Value::FLAG_HEAP, Value::FLAG_TRUE, Value::FLAG_FALSE, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN);
      dasm_put(Dst, 4211, Value::FLAG_TRUE, Value::FLAG_FALSE);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterCompareHH))) {
      dasm_put(Dst, 4261);
       } else {
         lava_warn("%s","Function InterpreterCompareHH address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterCompareHH)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterCompareHH))>>32));
       }
      dasm_put(Dst, 226);
#line 1979 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_NEVV:
      //|=>bc:
      //|  comp_eqne_vv BC_NEVV,Value::FLAG_FALSE,Value::FLAG_TRUE
      dasm_put(Dst, 4008, bc, Value::FLAG_REAL, Value::FLAG_REAL, Value::FLAG_FALSE, Value::FLAG_TRUE, Value::FLAG_HEAP);
      dasm_put(Dst, 4146, Value::FLAG_HEAP, Value::FLAG_FALSE, Value::FLAG_TRUE, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN);
      dasm_put(Dst, 4211, Value::FLAG_FALSE, Value::FLAG_TRUE);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterCompareHH))) {
      dasm_put(Dst, 4261);
       } else {
         lava_warn("%s","Function InterpreterCompareHH address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterCompareHH)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterCompareHH))>>32));
       }
      dasm_put(Dst, 226);
#line 1983 "src/interpreter/bytecode-interpreter.dasc"
      break;

    // For string equality comparison , we inline SSO comparison since
    // they are just checking the address are equal or not
    //|.macro eq_sv,BC,SlowPath,instr,false_jmp
    //|  instr_D
    //|  LdStr LREG,ARG2F
    //|  mov RREG,qword [STK+ARG3F*8]
    //|  CheckSSO LREG,>1
    //|  CheckSSOV RREG,>1

    //|.if USE_CMOV_COMP
    //|  mov ARG2, Value::FLAG_FALSE
    //|  cmp LREG,RREG
    //|  instr ARG2,dword [->FlagTrueConst]
    //|  mov dword [STK+ARG1F*8+4],ARG2
    //|.else
    //|  cmp LREG,RREG
    //|  false_jmp >8
    //|  mov dword [STK+ARG1F*8+4],Value::FLAG_TRUE
    //|  jmp >7
    //|8:
    //|  mov dword [STK+ARG1F*8+4],Value::FLAG_FALSE
    //|.endif

    //|7:
    //|  Dispatch

    //|1:
    //|  jmp ->SlowPath
    //|.endmacro

    //|.macro eq_vs,BC,SlowPath,instr,false_jmp
    //|  instr_D
    //|  mov LREG, qword [STK+ARG2F*8]
    //|  LdStr RREG,ARG3F
    //|  CheckSSOV LREG,>1
    //|  CheckSSO  RREG,>1

    //|.if USE_CMOV_COMP
    //|  mov ARG2, Value::FLAG_FALSE
    //|  cmp LREG,RREG
    //|  instr ARG2,dword [->FlagTrueConst]
    //|  mov dword [STK+ARG1F*8+4],ARG2
    //|.else
    //|  cmp LREG,RREG
    //|  false_jmp >8
    //|  mov dword [STK+ARG1F*8+4],Value::FLAG_TRUE
    //|  jmp >7
    //|8:
    //|  mov dword [STK+ARG1F*8+4],Value::FLAG_FALSE
    //|.endif

    //|7:
    //|  Dispatch

    //|1:
    //|  jmp ->SlowPath
    //|.endmacro

    case BC_EQSV:
      //|=> bc:
      //|  eq_sv BC_EQSV,InterpCompareSV,cmove,jne
      dasm_put(Dst, 4266,  bc, PrototypeLayout::kStringTableOffset, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, Value::FLAG_TRUE);
      dasm_put(Dst, 4369, Value::FLAG_FALSE);
#line 2046 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_EQVS:
      //|=> bc:
      //|  eq_vs BC_EQVS,InterpCompareVS,cmove,jne
      dasm_put(Dst, 4403,  bc, PrototypeLayout::kStringTableOffset, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, Value::FLAG_TRUE);
      dasm_put(Dst, 4507, Value::FLAG_FALSE);
#line 2050 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_NESV:
      //|=>bc:
      //|  eq_sv BC_NESV,InterpCompareSV,cmovne,je
      dasm_put(Dst, 4541, bc, PrototypeLayout::kStringTableOffset, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, Value::FLAG_TRUE);
      dasm_put(Dst, 4369, Value::FLAG_FALSE);
#line 2054 "src/interpreter/bytecode-interpreter.dasc"
      break;
    case BC_NEVS:
      //|=>bc:
      //|  eq_vs BC_NEVS,InterpCompareVS,cmovne,je
      dasm_put(Dst, 4644, bc, PrototypeLayout::kStringTableOffset, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, Value::FLAG_TRUE);
      dasm_put(Dst, 4507, Value::FLAG_FALSE);
#line 2058 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /* -------------------------------------------------
     * Unary                                           |
     * ------------------------------------------------*/

    // inline integers and reals inlined to be processed
    // and other types are throwed away to the slower
    // functions to help since we may need to support meta
    // function in the future
    case BC_NEGATE:
      //|=> bc:
      //|  instr_E
      //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      //|  jnb >8
      dasm_put(Dst, 4748,  bc, Value::FLAG_REAL);
#line 2073 "src/interpreter/bytecode-interpreter.dasc"

      //|  movsd, xmm0, qword [STK+ARG2F*8]
      //|  rconst_sign xmm1
      //|  xorpd xmm0, xmm1
      //|  movsd qword [STK+ARG1F*8], xmm0
      //|  Dispatch
      dasm_put(Dst, 4767, (unsigned int)((static_cast<std::uint64_t>(0x80000000)<<32)), (unsigned int)(((static_cast<std::uint64_t>(0x80000000)<<32))>>32));
#line 2079 "src/interpreter/bytecode-interpreter.dasc"

      //|8:
      //|  mov CARG1, RUNTIME
      //|  mov CARG2, qword [STK+ARG2F*8]
      //|  lea CARG3, [STK+ARG1F*8]
      //|  fcall InterpreterDoNegate
      dasm_put(Dst, 4814);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterDoNegate))) {
      dasm_put(Dst, 4828);
       } else {
         lava_warn("%s","Function InterpreterDoNegate address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterDoNegate)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterDoNegate))>>32));
       }
#line 2085 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 2086 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_NOT:
      //|=> bc:
      //|  instr_E
      //|  mov ARG3, Value::FLAG_FALSE
      dasm_put(Dst, 4833,  bc, Value::FLAG_FALSE);
#line 2092 "src/interpreter/bytecode-interpreter.dasc"
      // check if the value is a heap object
      //|  cmp word [STK+ARG2F*8+6], Value::FLAG_HEAP
      //|  je >1
      //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_FALSECOND
      //|  cmova ARG3, dword [->FlagTrueConst]
      //|1:
      //|  mov dword [STK+ARG1F*8+4], ARG3
      //|  Dispatch
      dasm_put(Dst, 4843, Value::FLAG_HEAP, Value::FLAG_FALSECOND);
#line 2100 "src/interpreter/bytecode-interpreter.dasc"
      break;

    // ------------------------------------------------
    // Branch                                         |
    // -----------------------------------------------*/

    // branch PC
    //|.macro branch_to,where,TEMP
    //|  mov TEMP,qword SAVED_PC
    //|  lea PC,[TEMP+where*4]
    //|.endmacro

    case BC_JMPT:
      //|=>bc:
      //|  instr_B
      //|  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      //|  je >2
      //|  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      //|  ja >1
      //|2:
      //|  branch_to ARG2F,ARG3F
      //|1:  // fallthrough
      //|  Dispatch
      dasm_put(Dst, 4894, bc, Value::FLAG_HEAP, Value::FLAG_FALSECOND);
#line 2123 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_JMPF:
      //|=>bc:
      //|  instr_B
      //|  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      //|  je >2
      //|  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      //|  jbe >2
      //|  branch_to ARG2F,ARG3F
      //|2: // fallthrough
      //|  Dispatch
      dasm_put(Dst, 4957, bc, Value::FLAG_HEAP, Value::FLAG_FALSECOND);
#line 2135 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_AND:
      //|=>bc:
      //|  instr_B
      //|  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      //|  je >1
      //|  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      //|  jbe >1
      //|  branch_to ARG2F,ARG3F
      //|1: // fallthrough
      //|  Dispatch
      dasm_put(Dst, 5018, bc, Value::FLAG_HEAP, Value::FLAG_FALSECOND);
#line 2147 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_OR:
      //|=>bc:
      //|  instr_B
      //|  cmp word  [STK+ARG1F*8+6], Value::FLAG_HEAP
      //|  je >2
      //|  cmp dword [STK+ARG1F*8+4], Value::FLAG_FALSECOND
      //|  ja >1
      //|2:
      //|  branch_to ARG2F,ARG3F
      //|1: // fallthrough
      //|  Dispatch
      dasm_put(Dst, 4894, bc, Value::FLAG_HEAP, Value::FLAG_FALSECOND);
#line 2160 "src/interpreter/bytecode-interpreter.dasc"
      break;

    //|.macro absolute_jmp,BC
    //|=>BC:
    //|  instr_G
    //|  branch_to ARG1F,ARG3F
    //|  Dispatch
    //|.endmacro

    case BC_JMP:
      //|  absolute_jmp,BC_JMP
      dasm_put(Dst, 5079, BC_JMP);
#line 2171 "src/interpreter/bytecode-interpreter.dasc"
      break;

    // ----------------------------------------------------------
    // Property/Upvalue/Global
    // ---------------------------------------------------------*/

    // A better way to implement property get/set is via IC (inline cache)
    // but currently we don't have IC states at bytecode level and we will
    // add it guide the JIT compilation phase. For interpreter, we will use
    // something simpler but good to capture most of the cases. Since we force
    // our internal hash use SSO's default hash value to serve as hash value
    // of the key, so we will use a trick that is used in LuaJIT here. For
    // key that is SSO, we will retrieve its hash value out and directly
    // generate index to anchor its main position inside of the *chain* and
    // if we miss we will fallback to the slow path

    // LREG --> Object*
    // RREG --> SSO*
    //|.macro find_sso_pos,output
    //|  mov T2,LREG

    //|  mov T2L, dword [T2+MapLayout::kCapacityOffset]

    //|  mov T1L, dword [RREG+SSOLayout::kHashOffset]

    // T2L capacity , T1L size
    //|  sub T2L,1

    // T1L -> index
    //|  and T1L,T2L

    // index into the array
    //|  lea T2L, [LREG+(MapLayout::kArrayOffset)]
    //|  lea T1L, [T1L+T1L*2]
    //|  lea T2L, [T2L+T1L*8]

    // save map's starting address
    //|  lea T1 , [LREG+MapLayout::kArrayOffset]

    // 1. check if this entry is *deleted* or *used*
    //|  mov LREGL, dword [T2L+MapEntryLayout::kFlagOffset]
    //|  test LREGL,((1<<30))
    //|  je >7  // not found main position is empty

    //|1:
    // 2. check if it is deleted
    //|  test LREGL,((1<<31))
    //|  jne >6 // deleted slots

    // 3. check if the key is a SSO
    //|  mov LREG, qword [T2L]
    //|  CheckSSO LREG,>6
    //|  mov LREG, qword [LREG]
    //|  cmp LREG, RREG
    //|  jne >6 // string not identical

    // now we find the entry
    //|  mov T2,qword [T2L+MapEntryLayout::kValueOffset]
    //|  mov qword [STK+output*8], T2
    //|  Dispatch

    // move to next iteration
    //|6:
    //|  mov LREGL, dword [T2L+MapEntryLayout::kFlagOffset]
    //|  test LREGL,((1<<29))
    //|  je >7
    //|  and LREGL, ((bits::BitOn<std::uint32_t,0,29>::value))
    //|  lea T2L  , [LREGL+LREGL*2]
    //|  lea T2L  , [T1+T2L*8]
    //|  mov LREGL, dword [T2L*8+MapEntryLayout::kFlagOffset]
    //|  jmp <1

    //|7:
    //|  jmp ->InterpPropGetNotFound

    //|.endmacro

    case BC_PROPGET:
      //|=>bc:
      //|  instr_B
      dasm_put(Dst, 5112, bc);
#line 2251 "src/interpreter/bytecode-interpreter.dasc"

      //|.if 1
      //|  cmp word [STK+ARG1F*8+6],Value::FLAG_HEAP
      //|  jne >8
      //|  mov LREG, qword [STK+ARG1F*8]
      //|  CheckObj LREG,>9
      //|.else
      //|  mov LREG, qword [STK+ARG1F*8]
      //|  CheckObjV LREG,>9
      //|.endif
      dasm_put(Dst, 5121, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, OBJECT_BIT_PATTERN);
#line 2261 "src/interpreter/bytecode-interpreter.dasc"

      //|  LdStr RREG,ARG2F
      dasm_put(Dst, 5154, PrototypeLayout::kStringTableOffset);
#line 2263 "src/interpreter/bytecode-interpreter.dasc"
      // assume RREG is an heap object since this should be guaranteed
      // by front-end
      //|  DerefPtrFromV RREG
      //|  CheckSSO RREG,>8
      dasm_put(Dst, 5167, -HOH_TYPE_OFFSET, SSO_BIT_PATTERN);
#line 2267 "src/interpreter/bytecode-interpreter.dasc"

      // find sso's position
      //|  find_sso_pos ACCIDX
      dasm_put(Dst, 5187, MapLayout::kCapacityOffset, SSOLayout::kHashOffset, (MapLayout::kArrayOffset), MapLayout::kArrayOffset, MapEntryLayout::kFlagOffset, ((1<<30)), ((1<<31)), -HOH_TYPE_OFFSET, SSO_BIT_PATTERN, MapEntryLayout::kValueOffset, 2040*8);
      dasm_put(Dst, 5281, MapEntryLayout::kFlagOffset, ((1<<29)), ((bits::BitOn<std::uint32_t,0,29>::value)), MapEntryLayout::kFlagOffset);
#line 2270 "src/interpreter/bytecode-interpreter.dasc"

      //|8: // should be done by slow path of InterpPorpGet
      //|  jmp ->InterpPropGet
      dasm_put(Dst, 5341);
#line 2273 "src/interpreter/bytecode-interpreter.dasc"

      //|9: // failed at *object*
      //|  jmp ->InterpPropNeedObject
      dasm_put(Dst, 5348);
#line 2276 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_PROPSET:
      // propset is directly yielded back to C++ functions
      //|=>bc:
      //|  instr_B
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  mov CARG2, qword [ACC]
      //|  mov CARG3, qword [STK+ARG1F*8]
      //|  LdStr CARG4,ARG2F
      //|  fcall InterpreterPropSet
      dasm_put(Dst, 5355, bc, RuntimeLayout::kCurPCOffset, PrototypeLayout::kStringTableOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterPropSet))) {
      dasm_put(Dst, 5397);
       } else {
         lava_warn("%s","Function InterpreterPropSet address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterPropSet)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterPropSet))>>32));
       }
#line 2288 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 2289 "src/interpreter/bytecode-interpreter.dasc"
      break;

    // Assume the ARG3F *already* contains index value ,4 bytes
    //|.macro index_list,oob,not_list
    //|  cmp word [STK+ARG2F*8+6], Value::FLAG_HEAP
    //|  jne ->InterpPropNeedObject

    //|  mov LREG, qword [STK+ARG2F*8]
    //|  CheckList LREG,not_list // if it is not a list then jump

    //|  cmp ARG3, dword [LREG+ListLayout::kSizeOffset]
    //|  jae ->oob

    //|  mov RREG, qword [LREG+ListLayout::kSliceOffset]
    //|  mov ARG2F,qword [RREG]

    //|  mov ARG2F, qword [ARG2F+ARG3F*8+SliceLayout::kArrayOffset]
    //|  mov qword [STK+ARG1F*8], ARG2F
    //|  Dispatch
    //|.endmacro

    case BC_IDXGET:
      //|=>bc:
      //|  instr_D
      //|  cmp word [STK+ARG3F*8+4], Value::FLAG_REAL
      //|  jnb >1
      //|  cvtsd2si ARG3, qword [STK+ARG3F*8]
      //|  test ARG3,ARG3
      //|  js ->InterpIdxOutOfBoundGet // out of bound
      dasm_put(Dst, 5402, bc, Value::FLAG_REAL);
#line 2318 "src/interpreter/bytecode-interpreter.dasc"

      // do the indexing for list or array
      //|  index_list,InterpIdxOutOfBoundGet,->InterpIdxGetI
      dasm_put(Dst, 5445, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, LIST_BIT_PATTERN, ListLayout::kSizeOffset, ListLayout::kSliceOffset, SliceLayout::kArrayOffset);
#line 2321 "src/interpreter/bytecode-interpreter.dasc"

      // general type index
      //|1:
      //|  mov CARG1, RUNTIME
      //|  mov CARG2, qword [STK+ARG2F*8]
      //|  mov CARG3, qword [STK+ARG3F*8]
      //|  lea CARG4, [STK+ARG1F*8]
      //|  fcall InterpreterIdxGet
      dasm_put(Dst, 5521);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterIdxGet))) {
      dasm_put(Dst, 5539);
       } else {
         lava_warn("%s","Function InterpreterIdxGet address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterIdxGet)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterIdxGet))>>32));
       }
#line 2329 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 2330 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_IDXGETI:
      //|=>bc:
      //|  instr_D
      //|  index_list,InterpIdxOutOfBoundGet,->InterpIdxGetI
      dasm_put(Dst, 5544, bc, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, LIST_BIT_PATTERN, ListLayout::kSizeOffset, ListLayout::kSliceOffset, SliceLayout::kArrayOffset);
#line 2336 "src/interpreter/bytecode-interpreter.dasc"
      break;


    //|.macro set_list,oob,not_list
    //|  cmp word [STK+ARG1F*8+6], Value::FLAG_HEAP
    //|  jne ->InterpPropNeedObject

    //|  mov LREG, qword [STK+ARG1F*8]
    //|  CheckList LREG,not_list

    //|  cmp ARG2, dword [LREG+ListLayout::kSizeOffset]
    //|  jae ->oob

    //|  mov RREG, qword [LREG+ListLayout::kSliceOffset]
    //|  mov ARG1F,qword [RREG]

    //|  mov LREG, qword [STK+ARG3F*8]
    //|  mov qword [ARG1F+ARG2F*8+ListLayout::kSliceOffset], LREG
    //|  Dispatch
    //|.endmacro


    case BC_IDXSET:
      //|=>bc:
      //|  instr_D
      dasm_put(Dst, 2219, bc);
#line 2361 "src/interpreter/bytecode-interpreter.dasc"

      // check the idx is a number
      //|  cmp word [STK+ARG2F*8+4], Value::FLAG_REAL
      //|  jnb >1
      dasm_put(Dst, 5637, Value::FLAG_REAL);
#line 2365 "src/interpreter/bytecode-interpreter.dasc"

      // conversion
      //|  cvtsd2si ARG2, qword [STK+ARG2F*8]
      dasm_put(Dst, 2261);
#line 2368 "src/interpreter/bytecode-interpreter.dasc"

      //|  test ARG2, ARG2
      //|  jz ->InterpIdxOutOfBoundSet
      dasm_put(Dst, 5650);
#line 2371 "src/interpreter/bytecode-interpreter.dasc"

      //|  set_list,InterpIdxOutOfBoundSet,->InterpIdxSetI
      dasm_put(Dst, 5657, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, LIST_BIT_PATTERN, ListLayout::kSizeOffset, ListLayout::kSliceOffset, ListLayout::kSliceOffset);
#line 2373 "src/interpreter/bytecode-interpreter.dasc"

      //|1:
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  mov CARG2, qword [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  mov CARG4, qword [STK+ARG3F*8]
      //|  fcall InterpreterIdxSet
      dasm_put(Dst, 5733, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterIdxSet))) {
      dasm_put(Dst, 5757);
       } else {
         lava_warn("%s","Function InterpreterIdxSet address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterIdxSet)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterIdxSet))>>32));
       }
#line 2381 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 2382 "src/interpreter/bytecode-interpreter.dasc"
      break;


    case BC_IDXSETI:
      //|=>bc:
      //|  instr_D
      //|  set_list,InterpIdxOutOfBoundSet,->InterpIdxSetI
      dasm_put(Dst, 5762, bc, Value::FLAG_HEAP, -HOH_TYPE_OFFSET, LIST_BIT_PATTERN, ListLayout::kSizeOffset, ListLayout::kSliceOffset, ListLayout::kSliceOffset);
#line 2389 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_UVGET:
      //|=>bc:
      //|  instr_B
      //|  LdUV LREG,ARG2F
      //|  mov  qword [STK+ARG1F*8], LREG
      //|  Dispatch
      dasm_put(Dst, 5855, bc, RuntimeLayout::kCurClsOffset, ClosureLayout::kUpValueOffset);
#line 2397 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_UVSET:
      //|=>bc:
      //|  instr_C
      //|  mov RREG, qword [STK+ARG2F*8]
      //|  StUV ARG1F,RREG
      //|  Dispatch
      dasm_put(Dst, 5901, bc, RuntimeLayout::kCurClsOffset, ClosureLayout::kUpValueOffset);
#line 2405 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_GSET:
      //|=>bc:
      //|  instr_C
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  LdStr CARG2, ARG1F
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  fcall InterpreterGSet
      dasm_put(Dst, 5947, bc, RuntimeLayout::kCurPCOffset, PrototypeLayout::kStringTableOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterGSet))) {
      dasm_put(Dst, 5981);
       } else {
         lava_warn("%s","Function InterpreterGSet address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterGSet)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterGSet))>>32));
       }
#line 2415 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 2416 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_GGET:
      //|=>bc:
      //|  instr_B
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  LdStr CARG3, ARG2F
      //|  fcall InterpreterGGet
      dasm_put(Dst, 5986, bc, RuntimeLayout::kCurPCOffset, PrototypeLayout::kStringTableOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterGGet))) {
      dasm_put(Dst, 6020);
       } else {
         lava_warn("%s","Function InterpreterGGet address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterGGet)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterGGet))>>32));
       }
#line 2426 "src/interpreter/bytecode-interpreter.dasc"
      //|  retbool
      dasm_put(Dst, 226);
#line 2427 "src/interpreter/bytecode-interpreter.dasc"
      break;

    /* ========================================================
     * Loop instructions
     *
     * Loop is optimized for situation that condition/step and
     * induction variable are all *integer* value
     * =======================================================*/
    case BC_FSTART:
      //|=>bc:
      //|  instr_B
      dasm_put(Dst, 5112, bc);
#line 2438 "src/interpreter/bytecode-interpreter.dasc"
      // must be boolean flag here
      //|  cmp dword [STK+ACCFIDX], Value::FLAG_FALSE
      //|  je >1
      //|2:
      //|  Dispatch
      //|1:
      //|  branch_to ARG2F,ARG3F
      //|  jmp <2
      dasm_put(Dst, 6025, Value::FLAG_FALSE);
#line 2446 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_FEND1:
      //|=>bc:
      //|  instr_E // actually TYPE_H instruction
      //|  cmp dword [STK+ARG1F*8+4], Value::FLAG_REAL
      //|  jnb ->InterpreterForEnd1
      dasm_put(Dst, 6075, bc, Value::FLAG_REAL);
#line 2453 "src/interpreter/bytecode-interpreter.dasc"

      //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      //|  jnb ->InterpreterForEnd1
      dasm_put(Dst, 6094, Value::FLAG_REAL);
#line 2456 "src/interpreter/bytecode-interpreter.dasc"

      //|  movsd xmm0, qword [STK+ARG1F*8]
      //|  ucomisd xmm0, qword [STK+ARG2F*8]
      //|  jae >8 // loop exit
      dasm_put(Dst, 6106);
#line 2460 "src/interpreter/bytecode-interpreter.dasc"

      //|  mov ARG1, dword [PC]
      //|  branch_to ARG1F,ARG3F
      //|7:
      //|  Dispatch
      //|8:
      //|  // skip the 4th argument
      //|  add PC,4
      //|  jmp <7
      dasm_put(Dst, 6124);
#line 2469 "src/interpreter/bytecode-interpreter.dasc"

      //|6: // fallback for situation that is not integer
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  mov CARG2, qword [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  mov CARG4L, dword [PC]
      //|  fcall InterpreterForEnd1
      dasm_put(Dst, 6167, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterForEnd1))) {
      dasm_put(Dst, 6190);
       } else {
         lava_warn("%s","Function InterpreterForEnd1 address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterForEnd1)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterForEnd1))>>32));
       }
#line 2477 "src/interpreter/bytecode-interpreter.dasc"
      // handle return value
      //|  test eax,eax
      //|  je ->InterpFail
      //|  mov PC, qword [RUNTIME+RuntimeLayout::kCurPCOffset]
      //|  Dispatch
      dasm_put(Dst, 6195, RuntimeLayout::kCurPCOffset);
#line 2482 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_FEND2:
      //|=>bc:
      //|  instr_D
      //|  cmp dword [STK+ARG1F*8+4], Value::FLAG_REAL
      //|  jnb >6
      //|  cmp dword [STK+ARG2F*8+4], Value::FLAG_REAL
      //|  jnb >6
      //|  cmp dword [STK+ARG3F*8+4], Value::FLAG_REAL
      //|  jnb >6
      dasm_put(Dst, 6227, bc, Value::FLAG_REAL, Value::FLAG_REAL, Value::FLAG_REAL);
#line 2493 "src/interpreter/bytecode-interpreter.dasc"

      //|  movsd xmm0, qword [STK+ARG1F*8]
      //|  addsd xmm0, qword [STK+ARG3F*8]
      //|  ucomisd xmm0, qword [STK+ARG2F*8]
      //|  movsd qword [STK+ARG1F*8], xmm0 // need to write back
      //|  jae >8 // loop exit
      dasm_put(Dst, 6278);
#line 2499 "src/interpreter/bytecode-interpreter.dasc"

      // fallthrough
      //|  mov ARG1, dword [PC]
      //|  branch_to ARG1F,ARG3F
      //|7:
      //|  Dispatch
      //|8:
      //|  add PC,4
      //|  jmp <7
      dasm_put(Dst, 6124);
#line 2508 "src/interpreter/bytecode-interpreter.dasc"

      //|6:
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3, qword [STK+ARG2F*8]
      //|  mov CARG4, qword [STK+ARG3F*8]
      //|  mov CARG5L, dword [PC]
      //|  fcall InterpreterForEnd2
      dasm_put(Dst, 6310, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterForEnd2))) {
      dasm_put(Dst, 6338);
       } else {
         lava_warn("%s","Function InterpreterForEnd2 address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterForEnd2)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterForEnd2))>>32));
       }
#line 2517 "src/interpreter/bytecode-interpreter.dasc"
      //|  test eax,eax
      //|  je ->InterpFail
      //|  mov PC, qword [RUNTIME+RuntimeLayout::kCurPCOffset]
      //|  Dispatch
      dasm_put(Dst, 6195, RuntimeLayout::kCurPCOffset);
#line 2521 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_FEVRSTART:
      //|=>bc:
      //|  instr_X
      //|  Dispatch
      dasm_put(Dst, 6343, bc);
#line 2527 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_FEVREND:
      //|=>bc:
      //|  instr_G
      //|  branch_to ARG1F,ARG3F
      //|  Dispatch
      dasm_put(Dst, 5079, bc);
#line 2534 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_BRK:
      //|  absolute_jmp BC_BRK
      dasm_put(Dst, 5079, BC_BRK);
#line 2538 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_CONT:
      //|  absolute_jmp BC_CONT
      dasm_put(Dst, 5079, BC_CONT);
#line 2542 "src/interpreter/bytecode-interpreter.dasc"
      break;

    // Foreach instructions
    case BC_FESTART:
      //|=>bc:
      //|  instr_B
      dasm_put(Dst, 5112, bc);
#line 2548 "src/interpreter/bytecode-interpreter.dasc"

      // TODO:: Worth optimizing for list/map ??
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3L, ARG2
      //|  fcall InterpreterFEStart
      dasm_put(Dst, 1088, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterFEStart))) {
      dasm_put(Dst, 6364);
       } else {
         lava_warn("%s","Function InterpreterFEStart address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterFEStart)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterFEStart))>>32));
       }
#line 2555 "src/interpreter/bytecode-interpreter.dasc"
      //|  test eax,eax
      //|  je ->InterpFail
      //|  mov PC, qword [RUNTIME+RuntimeLayout::kCurPCOffset]
      //|  Dispatch
      dasm_put(Dst, 6195, RuntimeLayout::kCurPCOffset);
#line 2559 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_FEEND:
      //|=>bc:
      //|  instr_B
      dasm_put(Dst, 5112, bc);
#line 2564 "src/interpreter/bytecode-interpreter.dasc"

      // TODO:: Worth optimizing for list/map ??
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  lea CARG2, [STK+ARG1F*8]
      //|  mov CARG3L,ARG2
      //|  fcall InterpreterFEEnd
      dasm_put(Dst, 1088, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterFEEnd))) {
      dasm_put(Dst, 6369);
       } else {
         lava_warn("%s","Function InterpreterFEEnd address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterFEEnd)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterFEEnd))>>32));
       }
#line 2571 "src/interpreter/bytecode-interpreter.dasc"
      //|  test eax,eax
      //|  je ->InterpFail
      //|  mov PC, qword [RUNTIME+RuntimeLayout::kCurPCOffset]
      //|  Dispatch
      dasm_put(Dst, 6195, RuntimeLayout::kCurPCOffset);
#line 2575 "src/interpreter/bytecode-interpreter.dasc"
      break;

    case BC_IDREF:
      //|=>bc:
      //|  instr_D
      dasm_put(Dst, 2219, bc);
#line 2580 "src/interpreter/bytecode-interpreter.dasc"

      // TODO:: Worth optimizing for list/map ??
      //|  savepc
      //|  mov CARG1, RUNTIME
      //|  mov CARG2, qword [STK+ARG1F*8]
      //|  lea CARG3, qword [STK+ARG2F*8]
      //|  lea CARG4, qword [STK+ARG3F*8]
      //|  fcall InterpreterIDref
      dasm_put(Dst, 6374, RuntimeLayout::kCurPCOffset);
       if(CheckAddress(reinterpret_cast<std::uintptr_t>(InterpreterIDref))) {
      dasm_put(Dst, 6396);
       } else {
         lava_warn("%s","Function InterpreterIDref address is not in 0-2GB");
      dasm_put(Dst, 218, (unsigned int)(reinterpret_cast<std::uintptr_t>(InterpreterIDref)), (unsigned int)((reinterpret_cast<std::uintptr_t>(InterpreterIDref))>>32));
       }
#line 2588 "src/interpreter/bytecode-interpreter.dasc"
      //|  test eax,eax
      //|  je ->InterpFail
      //|  mov PC, qword [RUNTIME+RuntimeLayout::kCurPCOffset]
      //|  Dispatch
      dasm_put(Dst, 6195, RuntimeLayout::kCurPCOffset);
#line 2592 "src/interpreter/bytecode-interpreter.dasc"
      break;

    default:
      //|=> bc:
      //|  Break
      dasm_put(Dst, 6401,  bc);
#line 2597 "src/interpreter/bytecode-interpreter.dasc"
      break;
  }
}

// Help Dasm to resolve external address via Index idx
int ResolveExternAddress( void** ctx , unsigned char* addr ,
                                       int idx,
                                       int type ) {
  (void)ctx;

  ExternSymbolTable* t = GetExternSymbolTable();
  ExternSymbolTable::iterator itr = t->find(extnames[idx]);

  lava_verify( itr != t->end() );

  void* ptr = itr->second;
  lava_verify(CheckAddress(reinterpret_cast<std::uintptr_t>(ptr)));

  int iptr = HorribleCast(ptr);
  lava_verify(reinterpret_cast<void*>(iptr) == ptr);

  if(type) {
    int end = HorribleCast(addr+4);

    // Check whether the address is overflowed or not. I think this is
    // not needed but just in cases we have a bug so we don't end up
    // calling into some wired places into our code
    std::int64_t ptr64 = static_cast<std::int64_t>(iptr);
    std::int64_t end64 = static_cast<std::int64_t>(end);

    lava_verify( (ptr64-end64) >= std::numeric_limits<int>::min() &&
                 (ptr64-end64) <= std::numeric_limits<int>::max() );

    return iptr - HorribleCast(addr+4);
  } else {
    return iptr;
  }
}

} // namespace

AssemblyInterpreter::AssemblyInterpreter():
  dispatch_interp_(),
  dispatch_record_(),
  dispatch_jit_   (),
  interp_helper_  (),
  interp_entry_   (),
  code_buffer_    (),
  code_size_      (),
  buffer_size_    ()
{}

AssemblyInterpreter::~AssemblyInterpreter() {
  if(interp_entry_) OS::FreeCodePage(code_buffer_,buffer_size_);
}

std::shared_ptr<AssemblyInterpreter> AssemblyInterpreter::Generate() {
  static std::shared_ptr<AssemblyInterpreter> interp;
  if(interp) return interp; // return interp if we already have a interpreter pointer

  // create a new interp object since this is our first time
  interp.reset( new AssemblyInterpreter() );

  // create a build context
  BuildContext bctx;

  // initialize dasm_State object
  dasm_init(&(bctx.dasm_ctx),2);

  // setup the freaking global
  void* glb_arr[GLBNAME__MAX];
  dasm_setupglobal(&(bctx.dasm_ctx),glb_arr,GLBNAME__MAX);

  // setup the dasm
  dasm_setup(&(bctx.dasm_ctx),actions);

  // initialize the tag value needed , at least for each BC we need one
  bctx.tag = DASM_GROWABLE_PC_SIZE;
  dasm_growpc(&(bctx.dasm_ctx), DASM_GROWABLE_PC_SIZE );

  // ----------------------------------------------------------
  // Order matters, it may change profile of our icache
  // ----------------------------------------------------------

  // build the helper
  GenerateHelper(&bctx);

  // build the prolog
  GenerateInterpMisc(&bctx);

  // generate all bytecode's routine
  for( int i = 0 ; i < SIZE_OF_BYTECODE ; ++i ) {
    GenerateOneBytecode(&bctx,static_cast<Bytecode>(i));
  }

  std::size_t code_size;

  // we should never fail at *linking* if our code is *correct*
  lava_verify(dasm_link(&(bctx.dasm_ctx),&code_size) ==0);

  // generate a buffer and set the proper protection field for that piece of
  // memory to make our code *work*
  std::size_t new_size;

  void* buffer = OS::CreateCodePage(code_size,&new_size);
  if(!buffer) {
    return std::shared_ptr<AssemblyInterpreter>();
  }

  // encode the assembly code into the buffer
  dasm_encode(&(bctx.dasm_ctx),buffer);

  // get all pc labels for entry of bytecode routine
  for( int i = 0 ; i < SIZE_OF_BYTECODE ; ++i ) {
    int off = dasm_getpclabel(&(bctx.dasm_ctx),i);
    interp->dispatch_interp_[i] =
      reinterpret_cast<void*>(static_cast<char*>(buffer) + off);
  }

  // get all pc labels for helper routines
  for( int i = INTERP_HELPER_START ; i < DASM_GROWABLE_PC_SIZE ; ++i ) {
    int off = dasm_getpclabel(&(bctx.dasm_ctx),i);
    interp->interp_helper_.push_back(
        reinterpret_cast<void*>(static_cast<char*>(buffer)+off));
  }

  // start of the code buffer
  interp->code_buffer_  = buffer;

  // get the *interpreter's* entry
  int off = dasm_getpclabel(&(bctx.dasm_ctx),INTERP_START);
  interp->interp_entry_ = reinterpret_cast<void*>(
      static_cast<char*>(buffer) + off);

  interp->buffer_size_  = new_size;
  interp->code_size_    = code_size;
  return interp;
}

Bytecode AssemblyInterpreter::CheckBytecodeRoutine( void* pc ) const {
  for( int i = 0 ; i < SIZE_OF_BYTECODE ; ++i ) {
    void* p = reinterpret_cast<void*>(pc);
    if(p == dispatch_interp_[i]) {
      return static_cast<Bytecode>(i);
    }
  }
  return SIZE_OF_BYTECODE;
}

int AssemblyInterpreter::CheckHelperRoutine( void* pc ) const {
  std::vector<void*>::const_iterator itr =
    std::find( interp_helper_.begin() , interp_helper_.end() , pc );
  if(itr != interp_helper_.end()) {
    return (static_cast<int>(std::distance(interp_helper_.begin(),itr))+INTERP_HELPER_START);
  } else {
    return -1;
  }
}

void AssemblyInterpreter::Dump( DumpWriter* writer ) const {
  ZydisDecoder decoder;
  ZydisDecoderInit( &decoder, ZYDIS_MACHINE_MODE_LONG_64,
                              ZYDIS_ADDRESS_WIDTH_64);

  ZydisFormatter formatter;
  ZydisFormatterInit(&formatter,ZYDIS_FORMATTER_STYLE_INTEL);

  std::uint64_t pc = reinterpret_cast<std::uint64_t>(code_buffer_);
  std::uint8_t* rp = static_cast<std::uint8_t*>(code_buffer_);
  std::size_t size = code_size_;

  writer->WriteL("CodeSize:%zu",code_size_);
  ZydisDecodedInstruction instr;
  while(ZYDIS_SUCCESS(
        ZydisDecoderDecodeBuffer(&decoder,rp,size,pc,&instr))) {

    char buffer[256];
    ZydisFormatterFormatInstruction(
        &formatter,&instr,buffer,sizeof(buffer));
    // check labels
    {
      Bytecode bc = CheckBytecodeRoutine(reinterpret_cast<void*>(pc));
      if(bc != SIZE_OF_BYTECODE) {
        writer->WriteL("Bytecode ===========> %s:",GetBytecodeName(bc));
      } else {
        int idx = CheckHelperRoutine(reinterpret_cast<void*>(pc));
        if(idx >= 0) {
          writer->WriteL("Helper ===========> %s:",GetInterpHelperName(idx));
        }
      }
    }
    writer->WriteL("%016" PRIX64 " (%d) %s",pc,instr.length,buffer);
    rp += instr.length;
    size -= instr.length;
    pc += instr.length;
  }
}

AssemblyInterpreter::Instance::Instance( const std::shared_ptr<AssemblyInterpreter>& interp ):
  dispatch_interp_(),
  dispatch_record_(),
  dispatch_jit_   (),
  interp_         (interp) {

  memcpy(dispatch_interp_,interp->dispatch_interp_,sizeof(dispatch_interp_));
  memcpy(dispatch_record_,interp->dispatch_record_,sizeof(dispatch_record_));
  memcpy(dispatch_jit_   ,interp->dispatch_jit_   ,sizeof(dispatch_jit_   ));
}

bool AssemblyInterpreter::Instance::Run( Context* context , const Handle<Script>& script ,
                                                            const Handle<Object>& globals,
                                                            std::string* error,
                                                            Value* rval ) {

  Runtime* rt = context->gc()->GetInterpreterRuntime(script.ref(), globals.ref(), error);
  // Entry of our assembly interpreter
  Main m = reinterpret_cast<Main>(interp_->interp_entry_);

  // Interpret the bytecode
  bool ret = m(rt,rt->cur_proto,reinterpret_cast<void*>(rt->stack),
                                const_cast<void*>(
                                  reinterpret_cast<const void*>((*(rt->cur_proto))->code_buffer())),
                                dispatch_interp_);
  // Check return
  if(ret) {
    *rval = rt->ret;
  }

  context->gc()->ReturnInterpreterRuntime(rt);
  return ret;
}

} // namespace interpreter
} // namespace lavascript
