1) refactory binary node into multiple different nodes
2) a new effect tracing algorithm and different memory node :

     2.1) reference node , these nodes perform a specific hash lookup
          inside of the code to find out the reference wrt a certain
          key. a failure result in deoptimization or fallback path

     1) object_get_ref
     2) object_update_ref
     3) object_set_ref

     4) list_get_ref
     5) list_set_ref

     the above node participate in GVN to reduce overhead like:

     if(a.a) {
       a.a = 20;
       insert(a,"b",20); // this is barrier node that could invalidate all previous
                         // hash lookup due to the internal rehashing mechanism ,so
                         // any reference cannot be GVNed with the previous one
                         // to avoid it, the insert will generate a memory barrier
                         // and then all the a.a will watch to this barrier. this
                         // barrier is called MemoryRegion. any operation that could
                         // cause 1) GC 2) Rehashing or Resizing of the list 3) function
                         // call that cannot be inlined 4) dynamic dispatch
     }

     a.a = 30;           // this object_get_ref node is different from above due to
                         // that the insert result in a new MemoryRegion created

     essentially turns into a single hash lookup for the reference and then
     check that reference has a true value and then set to that reference
     a value 20

     2.2) pointer dereference/reference node , these node does not guard
          the return value from object_get_ref.

     1) ref_get
     2) ref_set

Weak type language's alias analyzing is always pain in the but






